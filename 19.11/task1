using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace KnapsackProblem
{
    public class KnapsackSolver
    {
        public static KnapsackResult Solve01Knapsack(int[] weights, int[] values, int capacity)
        {
            int n = weights.Length;
            int[,] dp = new int[n + 1, capacity + 1];

            for (int i = 1; i <= n; i++)
            {
                for (int w = 0; w <= capacity; w++)
                {
                    if (weights[i - 1] <= w)
                    {
                        dp[i, w] = Math.Max(
                            dp[i - 1, w],
                            dp[i - 1, w - weights[i - 1]] + values[i - 1]
                        );
                    }
                    else
                    {
                        dp[i, w] = dp[i - 1, w];
                    }
                }
            }

            List<int> selectedItems = ReconstructSolution(dp, weights, capacity);

            return new KnapsackResult
            {
                MaxValue = dp[n, capacity],
                SelectedItems = selectedItems,
                DPTable = dp
            };
        }

        public static KnapsackResult Solve01KnapsackOptimized(int[] weights, int[] values, int capacity)
        {
            int n = weights.Length;
            int[] dp = new int[capacity + 1];

            for (int i = 0; i < n; i++)
            {
                for (int w = capacity; w >= weights[i]; w--)
                {
                    dp[w] = Math.Max(dp[w], dp[w - weights[i]] + values[i]);
                }
            }

            List<int> selectedItems = ReconstructSolutionOptimized(weights, values, capacity, dp);

            return new KnapsackResult
            {
                MaxValue = dp[capacity],
                SelectedItems = selectedItems,
                DPTable = ConvertTo2D(dp, n, capacity)
            };
        }

        public static KnapsackResult SolveBoundedKnapsack(int[] weights, int[] values, int[] quantities, int capacity)
        {
            int n = weights.Length;
            int[] dp = new int[capacity + 1];

            for (int i = 0; i < n; i++)
            {
                for (int k = 1; k <= quantities[i]; k++)
                {
                    for (int w = capacity; w >= weights[i]; w--)
                    {
                        dp[w] = Math.Max(dp[w], dp[w - weights[i]] + values[i]);
                    }
                }
            }

            return new KnapsackResult
            {
                MaxValue = dp[capacity],
                SelectedItems = new List<int>(),
                DPTable = ConvertTo2D(dp, n, capacity)
            };
        }

        public static KnapsackResult SolveUnboundedKnapsack(int[] weights, int[] values, int capacity)
        {
            int n = weights.Length;
            int[] dp = new int[capacity + 1];

            for (int w = 0; w <= capacity; w++)
            {
                for (int i = 0; i < n; i++)
                {
                    if (weights[i] <= w)
                    {
                        dp[w] = Math.Max(dp[w], dp[w - weights[i]] + values[i]);
                    }
                }
            }

            return new KnapsackResult
            {
                MaxValue = dp[capacity],
                SelectedItems = new List<int>(),
                DPTable = ConvertTo2D(dp, n, capacity)
            };
        }

        private static List<int> ReconstructSolution(int[,] dp, int[] weights, int capacity)
        {
            List<int> selectedItems = new List<int>();
            int n = weights.Length;
            int w = capacity;

            for (int i = n; i > 0; i--)
            {
                if (dp[i, w] != dp[i - 1, w])
                {
                    selectedItems.Add(i - 1);
                    w -= weights[i - 1];
                }
            }

            selectedItems.Reverse();
            return selectedItems;
        }

        private static List<int> ReconstructSolutionOptimized(int[] weights, int[] values, int capacity, int[] dp)
        {
            List<int> selectedItems = new List<int>();
            int n = weights.Length;
            int w = capacity;

            bool[,] decision = new bool[n, capacity + 1];
            int[] tempDp = new int[capacity + 1];

            for (int i = 0; i < n; i++)
            {
                for (int currentW = capacity; currentW >= weights[i]; currentW--)
                {
                    int withoutItem = tempDp[currentW];
                    int withItem = tempDp[currentW - weights[i]] + values[i];

                    if (withItem > withoutItem)
                    {
                        tempDp[currentW] = withItem;
                        decision[i, currentW] = true;
                    }
                    else
                    {
                        tempDp[currentW] = withoutItem;
                        decision[i, currentW] = false;
                    }
                }
            }

            w = capacity;
            for (int i = n - 1; i >= 0; i--)
            {
                if (decision[i, w])
                {
                    selectedItems.Add(i);
                    w -= weights[i];
                }
            }

            selectedItems.Reverse();
            return selectedItems;
        }

        private static int[,] ConvertTo2D(int[] dp, int n, int capacity)
        {
            int[,] result = new int[n + 1, capacity + 1];
            for (int w = 0; w <= capacity; w++)
            {
                result[0, w] = 0;
            }

            for (int i = 1; i <= n; i++)
            {
                for (int w = 0; w <= capacity; w++)
                {
                    result[i, w] = dp[w];
                }
            }

            return result;
        }

        public static void PrintStepByStepSolution(KnapsackResult result, int[] weights, int[] values, int capacity)
        {
            Console.WriteLine("=== ПОШАГОВОЕ РЕШЕНИЕ ЗАДАЧИ О РЮКЗАКЕ ===");
            Console.WriteLine($"Максимальная стоимость: {result.MaxValue}");
            Console.WriteLine($"Вместимость рюкзака: {capacity}");
            Console.WriteLine();

            Console.WriteLine("Выбранные предметы:");
            if (result.SelectedItems.Count > 0)
            {
                int totalWeight = 0;
                int totalValue = 0;

                foreach (int itemIndex in result.SelectedItems)
                {
                    totalWeight += weights[itemIndex];
                    totalValue += values[itemIndex];
                    Console.WriteLine($"  Предмет {itemIndex + 1}: вес={weights[itemIndex]}, стоимость={values[itemIndex]}");
                }

                Console.WriteLine($"Итого: вес={totalWeight}, стоимость={totalValue}");
            }
            else
            {
                Console.WriteLine("  Предметы не выбраны");
            }

            Console.WriteLine();
            PrintDPTable(result.DPTable, weights.Length, capacity);
        }

        private static void PrintDPTable(int[,] dp, int n, int capacity)
        {
            Console.WriteLine("Таблица динамического программирования:");
            Console.Write("i\\w|");
            for (int w = 0; w <= Math.Min(capacity, 10); w++)
            {
                Console.Write($"{w,3}");
            }
            Console.WriteLine();
            Console.WriteLine(new string('-', 4 + Math.Min(capacity, 10) * 3));

            for (int i = 0; i <= Math.Min(n, 10); i++)
            {
                Console.Write($"{i,2} |");
                for (int w = 0; w <= Math.Min(capacity, 10); w++)
                {
                    Console.Write($"{dp[i, w],3}");
                }
                Console.WriteLine();
            }

            if (n > 10 || capacity > 10)
            {
                Console.WriteLine($"(показаны первые 10 строк и столбцов из {n} и {capacity})");
            }
        }
    }

    public class KnapsackResult
    {
        public int MaxValue { get; set; }
        public List<int> SelectedItems { get; set; }
        public int[,] DPTable { get; set; }

        public KnapsackResult()
        {
            SelectedItems = new List<int>();
        }
    }

    public enum SegmentTreeOperation
    {
        Sum,
        Min,
        Max
    }

    public class SegmentTree
    {
        private readonly long[] _tree;
        private readonly long[] _lazy;
        private readonly long[] _original;
        private readonly int _n;
        private readonly SegmentTreeOperation _operation;

        public SegmentTree(long[] array, SegmentTreeOperation operation = SegmentTreeOperation.Sum)
        {
            _original = (long[])array.Clone();
            _n = array.Length;
            _operation = operation;
            _tree = new long[4 * _n];
            _lazy = new long[4 * _n];
            Build(1, 0, _n - 1);
        }

        private SegmentTree(long[] tree, long[] lazy, long[] original, int n, SegmentTreeOperation operation)
        {
            _tree = (long[])tree.Clone();
            _lazy = (long[])lazy.Clone();
            _original = (long[])original.Clone();
            _n = n;
            _operation = operation;
        }

        private void Build(int node, int left, int right)
        {
            if (left == right)
            {
                _tree[node] = _original[left];
                return;
            }

            int mid = (left + right) / 2;
            Build(2 * node, left, mid);
            Build(2 * node + 1, mid + 1, right);

            _tree[node] = Combine(_tree[2 * node], _tree[2 * node + 1]);
        }

        private long Combine(long left, long right)
        {
            return _operation switch
            {
                SegmentTreeOperation.Sum => left + right,
                SegmentTreeOperation.Min => Math.Min(left, right),
                SegmentTreeOperation.Max => Math.Max(left, right),
                _ => throw new ArgumentException("Unknown operation")
            };
        }

        private void PushLazy(int node, int left, int right)
        {
            if (_lazy[node] != 0)
            {
                ApplyLazyToNode(node, left, right, _lazy[node]);

                if (left != right)
                {
                    _lazy[2 * node] += _lazy[node];
                    _lazy[2 * node + 1] += _lazy[node];
                }

                _lazy[node] = 0;
            }
        }

        private void ApplyLazyToNode(int node, int left, int right, long value)
        {
            switch (_operation)
            {
                case SegmentTreeOperation.Sum:
                    _tree[node] += value * (right - left + 1);
                    break;
                case SegmentTreeOperation.Min:
                    _tree[node] += value;
                    break;
                case SegmentTreeOperation.Max:
                    _tree[node] += value;
                    break;
            }
        }

        public long Query(int queryLeft, int queryRight)
        {
            return Query(1, 0, _n - 1, queryLeft, queryRight);
        }

        private long Query(int node, int left, int right, int queryLeft, int queryRight)
        {
            PushLazy(node, left, right);

            if (queryLeft <= left && right <= queryRight)
                return _tree[node];

            int mid = (left + right) / 2;

            if (queryRight <= mid)
                return Query(2 * node, left, mid, queryLeft, queryRight);

            if (queryLeft > mid)
                return Query(2 * node + 1, mid + 1, right, queryLeft, queryRight);

            long leftResult = Query(2 * node, left, mid, queryLeft, queryRight);
            long rightResult = Query(2 * node + 1, mid + 1, right, queryLeft, queryRight);

            return Combine(leftResult, rightResult);
        }

        public void UpdateRange(int updateLeft, int updateRight, long value)
        {
            UpdateRange(1, 0, _n - 1, updateLeft, updateRight, value);
        }

        private void UpdateRange(int node, int left, int right, int updateLeft, int updateRight, long value)
        {
            PushLazy(node, left, right);

            if (updateLeft > right || updateRight < left)
                return;

            if (updateLeft <= left && right <= updateRight)
            {
                ApplyLazyToNode(node, left, right, value);

                if (left != right)
                {
                    _lazy[2 * node] += value;
                    _lazy[2 * node + 1] += value;
                }
                return;
            }

            int mid = (left + right) / 2;
            UpdateRange(2 * node, left, mid, updateLeft, updateRight, value);
            UpdateRange(2 * node + 1, mid + 1, right, updateLeft, updateRight, value);

            _tree[node] = Combine(_tree[2 * node], _tree[2 * node + 1]);
        }

        public void Update(int index, long value)
        {
            UpdateRange(index, index, value - _original[index]);
            _original[index] = value;
        }

        public long[] GetArray()
        {
            return (long[])_original.Clone();
        }

        public SegmentTree CreatePersistentVersion()
        {
            return new SegmentTree(_tree, _lazy, _original, _n, _operation);
        }

        public string Visualize()
        {
            var sb = new StringBuilder();
            sb.AppendLine($"Segment Tree (Operation: {_operation})");
            Visualize(1, 0, _n - 1, 0, sb);
            return sb.ToString();
        }

        private void Visualize(int node, int left, int right, int depth, StringBuilder sb)
        {
            if (node >= _tree.Length || _tree[node] == 0) return;

            sb.Append(' ', depth * 2);
            sb.AppendLine($"Node {node}: [{left}-{right}] = {_tree[node]} (lazy: {_lazy[node]})");

            if (left != right)
            {
                int mid = (left + right) / 2;
                Visualize(2 * node, left, mid, depth + 1, sb);
                Visualize(2 * node + 1, mid + 1, right, depth + 1, sb);
            }
        }
    }

    public class PersistentSegmentTreeManager
    {
        private readonly List<SegmentTree> _versions = new List<SegmentTree>();
        private readonly long[] _initialArray;
        private readonly SegmentTreeOperation _operation;

        public PersistentSegmentTreeManager(long[] array, SegmentTreeOperation operation = SegmentTreeOperation.Sum)
        {
            _initialArray = (long[])array.Clone();
            _operation = operation;
            _versions.Add(new SegmentTree(array, operation));
        }

        public int CreateVersion()
        {
            _versions.Add(_versions[^1].CreatePersistentVersion());
            return _versions.Count - 1;
        }

        public SegmentTree GetVersion(int version)
        {
            if (version < 0 || version >= _versions.Count)
                throw new ArgumentException("Invalid version");

            return _versions[version];
        }

        public int VersionCount => _versions.Count;
    }

    public class Edge
    {
        public int To { get; set; }
        public int Weight { get; set; }
        public string Label { get; set; }

        public Edge(int to, int weight, string label = "")
        {
            To = to;
            Weight = weight;
            Label = label;
        }
    }

    public class Graph
    {
        private readonly List<Edge>[] _adjacencyList;
        public int VerticesCount { get; }
        public int EdgesCount { get; private set; }

        public Graph(int verticesCount)
        {
            VerticesCount = verticesCount;
            _adjacencyList = new List<Edge>[verticesCount];
            for (int i = 0; i < verticesCount; i++)
            {
                _adjacencyList[i] = new List<Edge>();
            }
        }

        public void AddEdge(int from, int to, int weight, string label = "")
        {
            if (from < 0 || from >= VerticesCount || to < 0 || to >= VerticesCount)
                throw new ArgumentException("Invalid vertex index");

            _adjacencyList[from].Add(new Edge(to, weight, label));
            EdgesCount++;
        }

        public void AddBidirectionalEdge(int from, int to, int weight, string label = "")
        {
            AddEdge(from, to, weight, label);
            AddEdge(to, from, weight, label);
        }

        public List<Edge> GetEdges(int vertex)
        {
            return _adjacencyList[vertex];
        }

        public void PrintGraph()
        {
            Console.WriteLine("Структура графа:");
            for (int i = 0; i < VerticesCount; i++)
            {
                if (_adjacencyList[i].Count > 0)
                {
                    Console.Write($"Вершина {i}: ");
                    foreach (var edge in _adjacencyList[i])
                    {
                        Console.Write($"[→{edge.To}(w:{edge.Weight})] ");
                    }
                    Console.WriteLine();
                }
            }
        }
    }

    public class ShortestPathResult
    {
        public long[] Distances { get; set; }
        public List<int>[] PreviousVertices { get; set; }
        public bool HasNegativeCycle { get; set; }
        public int Source { get; set; }

        public ShortestPathResult(int verticesCount, int source)
        {
            Distances = new long[verticesCount];
            PreviousVertices = new List<int>[verticesCount];
            for (int i = 0; i < verticesCount; i++)
            {
                PreviousVertices[i] = new List<int>();
                Distances[i] = long.MaxValue;
            }
            Source = source;
            Distances[source] = 0;
        }
    }

    public class DijkstraAllPaths
    {
        public static ShortestPathResult FindAllShortestPaths(Graph graph, int source)
        {
            int n = graph.VerticesCount;
            var result = new ShortestPathResult(n, source);

            var priorityQueue = new SortedSet<(long distance, int vertex)>();

            result.Distances[source] = 0;
            priorityQueue.Add((0, source));

            while (priorityQueue.Count > 0)
            {
                var current = priorityQueue.Min;
                priorityQueue.Remove(current);
                long currentDistance = current.distance;
                int currentVertex = current.vertex;

                if (currentDistance > result.Distances[currentVertex])
                    continue;

                foreach (var edge in graph.GetEdges(currentVertex))
                {
                    long newDistance = currentDistance + edge.Weight;

                    if (newDistance == result.Distances[edge.To])
                    {
                        if (!result.PreviousVertices[edge.To].Contains(currentVertex))
                        {
                            result.PreviousVertices[edge.To].Add(currentVertex);
                        }
                    }
                    else if (newDistance < result.Distances[edge.To])
                    {
                        result.Distances[edge.To] = newDistance;
                        result.PreviousVertices[edge.To].Clear();
                        result.PreviousVertices[edge.To].Add(currentVertex);
                        priorityQueue.Add((newDistance, edge.To));
                    }
                }
            }

            return result;
        }

        public static List<List<int>> GetAllShortestPaths(ShortestPathResult result, int target)
        {
            var allPaths = new List<List<int>>();

            if (result.Distances[target] == long.MaxValue)
                return allPaths;

            var currentPath = new List<int>();
            DFSAllPaths(result, target, currentPath, allPaths);

            foreach (var path in allPaths)
            {
                path.Reverse();
            }

            return allPaths;
        }

        private static void DFSAllPaths(ShortestPathResult result, int current,
            List<int> currentPath, List<List<int>> allPaths)
        {
            currentPath.Add(current);

            if (current == result.Source)
            {
                allPaths.Add(new List<int>(currentPath));
                currentPath.RemoveAt(currentPath.Count - 1);
                return;
            }

            foreach (int prev in result.PreviousVertices[current])
            {
                DFSAllPaths(result, prev, currentPath, allPaths);
            }

            currentPath.RemoveAt(currentPath.Count - 1);
        }

        public static bool HasNegativeCycle(Graph graph, int source)
        {
            int n = graph.VerticesCount;
            long[] distances = new long[n];
            Array.Fill(distances, long.MaxValue);
            distances[source] = 0;

            for (int i = 0; i < n - 1; i++)
            {
                for (int u = 0; u < n; u++)
                {
                    if (distances[u] == long.MaxValue) continue;

                    foreach (var edge in graph.GetEdges(u))
                    {
                        if (distances[u] + edge.Weight < distances[edge.To])
                        {
                            distances[edge.To] = distances[u] + edge.Weight;
                        }
                    }
                }
            }

            for (int u = 0; u < n; u++)
            {
                if (distances[u] == long.MaxValue) continue;

                foreach (var edge in graph.GetEdges(u))
                {
                    if (distances[u] + edge.Weight < distances[edge.To])
                    {
                        return true;
                    }
                }
            }

            return false;
        }
    }

    public class GraphVisualizer
    {
        public static void PrintAllPaths(List<List<int>> allPaths, ShortestPathResult result, int target)
        {
            if (allPaths.Count == 0)
            {
                Console.WriteLine($"Пути из {result.Source} в {target} не существует");
                return;
            }

            Console.WriteLine($"Найдено {allPaths.Count} кратчайших путей из {result.Source} в {target}:");
            Console.WriteLine($"Длина пути: {result.Distances[target]}");
            Console.WriteLine();

            for (int i = 0; i < allPaths.Count; i++)
            {
                Console.Write($"Путь {i + 1}: ");
                Console.WriteLine(string.Join(" → ", allPaths[i]));
            }
        }

        public static void PrintShortestPathTree(ShortestPathResult result)
        {
            Console.WriteLine("\nДерево кратчайших путей:");
            for (int i = 0; i < result.Distances.Length; i++)
            {
                if (result.Distances[i] == long.MaxValue)
                {
                    Console.WriteLine($"Вершина {i}: недостижима");
                }
                else
                {
                    Console.Write($"Вершина {i}: расстояние = {result.Distances[i]}, предки = [");
                    Console.Write(string.Join(", ", result.PreviousVertices[i]));
                    Console.WriteLine("]");
                }
            }
        }

        public static void GenerateGraphvizCode(Graph graph, ShortestPathResult result, int target, string filename = "graph")
        {
            var sb = new StringBuilder();
            sb.AppendLine("digraph G {");
            sb.AppendLine("  rankdir=TB;");
            sb.AppendLine("  node [shape=circle];");

            for (int i = 0; i < graph.VerticesCount; i++)
            {
                string color = "black";
                if (i == result.Source)
                    color = "green";
                else if (i == target)
                    color = "red";

                sb.AppendLine($"  {i} [color={color}];");
            }

            for (int i = 0; i < graph.VerticesCount; i++)
            {
                foreach (var edge in graph.GetEdges(i))
                {
                    bool isInShortestPath = result.PreviousVertices[edge.To].Contains(i) &&
                                           result.Distances[edge.To] == result.Distances[i] + edge.Weight;

                    string style = isInShortestPath ? "bold" : "dashed";
                    string color = isInShortestPath ? "red" : "black";

                    sb.AppendLine($"  {i} -> {edge.To} [label=\"{edge.Weight}\", style={style}, color={color}];");
                }
            }

            sb.AppendLine("}");

            System.IO.File.WriteAllText($"{filename}.dot", sb.ToString());
            Console.WriteLine($"Граф сохранён в {filename}.dot (используйте Graphviz для визуализации)");
        }
    }

    public class SegmentTreePerformanceTester
    {
        public static void TestPerformance(int n = 1000000)
        {
            Console.WriteLine($"=== ТЕСТ ПРОИЗВОДИТЕЛЬНОСТИ (n = {n}) ===");

            var random = new Random();
            var array = new long[n];
            for (int i = 0; i < n; i++)
            {
                array[i] = random.Next(1, 1000);
            }

            TestOperation(array, SegmentTreeOperation.Sum, "Sum");
            TestOperation(array, SegmentTreeOperation.Min, "Min");
            TestOperation(array, SegmentTreeOperation.Max, "Max");
        }

        private static void TestOperation(long[] array, SegmentTreeOperation operation, string operationName)
        {
            Console.WriteLine($"\n--- Тест операции {operationName} ---");

            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            var tree = new SegmentTree(array, operation);
            var buildTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Построение дерева: {buildTime} мс");

            stopwatch.Restart();
            int queryCount = Math.Min(100000, array.Length / 10);
            long totalQueryResult = 0;

            for (int i = 0; i < queryCount; i++)
            {
                int left = i % (array.Length - 100);
                int right = left + 99;
                totalQueryResult += tree.Query(left, right);
            }

            var queryTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"{queryCount} запросов: {queryTime} мс");
            Console.WriteLine($"Среднее время запроса: {(double)queryTime / queryCount:F6} мс");

            stopwatch.Restart();
            int updateCount = Math.Min(10000, array.Length / 100);

            for (int i = 0; i < updateCount; i++)
            {
                int left = i % (array.Length - 50);
                int right = left + 49;
                tree.UpdateRange(left, right, i % 100);
            }

            var updateTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"{updateCount} обновлений диапазона: {updateTime} мс");
            Console.WriteLine($"Среднее время обновления: {(double)updateTime / updateCount:F6} мс");

            long memoryUsed = GC.GetTotalMemory(true);
            Console.WriteLine($"Использование памяти: {memoryUsed / 1024 / 1024} МБ");
        }
    }

    public class GraphPerformanceTester
    {
        public static void TestPerformance(int vertices = 10000, int edges = 50000)
        {
            Console.WriteLine($"=== ТЕСТ ПРОИЗВОДИТЕЛЬНОСТИ (V={vertices}, E={edges}) ===");

            var random = new Random();
            var graph = new Graph(vertices);

            for (int i = 0; i < edges; i++)
            {
                int from = random.Next(vertices);
                int to = random.Next(vertices);
                int weight = random.Next(1, 100);
                graph.AddEdge(from, to, weight);
            }

            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            int source = random.Next(vertices);
            var result = DijkstraAllPaths.FindAllShortestPaths(graph, source);

            var dijkstraTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Алгоритм Дейкстры: {dijkstraTime} мс");

            stopwatch.Restart();
            int testTarget = random.Next(vertices);
            var paths = DijkstraAllPaths.GetAllShortestPaths(result, testTarget);

            var pathRecoveryTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Восстановление {paths.Count} путей: {pathRecoveryTime} мс");

            long memoryUsed = GC.GetTotalMemory(true);
            Console.WriteLine($"Использование памяти: {memoryUsed / 1024 / 1024} МБ");

            int unreachable = result.Distances.Count(d => d == long.MaxValue);
            Console.WriteLine($"Недостижимых вершин: {unreachable}/{vertices}");
        }
    }

    public class SuffixTreeNode
    {
        public Dictionary<char, SuffixTreeNode> Children { get; set; }
        public int Start { get; set; }
        public int End { get; set; }
        public SuffixTreeNode SuffixLink { get; set; }
        public int SuffixIndex { get; set; } = -1;

        public SuffixTreeNode(int start, int end)
        {
            Children = new Dictionary<char, SuffixTreeNode>();
            Start = start;
            End = end;
        }

        public int Length => End - Start + 1;
    }

    public class SuffixTree
    {
        private readonly string _text;
        private readonly SuffixTreeNode _root;
        private SuffixTreeNode _activeNode;
        private int _activeEdge = -1;
        private int _activeLength = 0;
        private int _remainingSuffixCount = 0;
        private int _leafEnd = -1;
        private int _position = -1;

        public string Text => _text;

        public SuffixTree(string text)
        {
            _text = text + "$";
            _root = new SuffixTreeNode(-1, -1);
            _root.SuffixLink = _root;
            _activeNode = _root;
            _leafEnd = -1;

            BuildTree();
        }

        private void BuildTree()
        {
            for (_position = 0; _position < _text.Length; _position++)
            {
                _leafEnd = _position;
                _remainingSuffixCount++;
                SuffixTreeNode lastNewNode = null;

                while (_remainingSuffixCount > 0)
                {
                    if (_activeLength == 0)
                    {
                        _activeEdge = _position;
                    }

                    char currentChar = _text[_activeEdge];

                    if (!_activeNode.Children.ContainsKey(currentChar))
                    {
                        _activeNode.Children[currentChar] = new SuffixTreeNode(_position, _leafEnd);

                        if (lastNewNode != null)
                        {
                            lastNewNode.SuffixLink = _activeNode;
                            lastNewNode = null;
                        }
                    }
                    else
                    {
                        SuffixTreeNode next = _activeNode.Children[currentChar];
                        int edgeLength = next.Length;

                        if (_activeLength >= edgeLength)
                        {
                            _activeEdge += edgeLength;
                            _activeLength -= edgeLength;
                            _activeNode = next;
                            continue;
                        }

                        if (_text[next.Start + _activeLength] == _text[_position])
                        {
                            if (lastNewNode != null && _activeNode != _root)
                            {
                                lastNewNode.SuffixLink = _activeNode;
                                lastNewNode = null;
                            }
                            _activeLength++;
                            break;
                        }

                        SuffixTreeNode split = new SuffixTreeNode(next.Start, next.Start + _activeLength - 1);
                        _activeNode.Children[currentChar] = split;

                        split.Children[_text[_position]] = new SuffixTreeNode(_position, _leafEnd);

                        next.Start += _activeLength;
                        split.Children[_text[next.Start]] = next;

                        if (lastNewNode != null)
                        {
                            lastNewNode.SuffixLink = split;
                        }

                        lastNewNode = split;
                    }

                    _remainingSuffixCount--;

                    if (_activeNode == _root && _activeLength > 0)
                    {
                        _activeLength--;
                        _activeEdge = _position - _remainingSuffixCount + 1;
                    }
                    else if (_activeNode != _root)
                    {
                        _activeNode = _activeNode.SuffixLink;
                    }
                }
            }

            SetSuffixIndices(_root, 0);
        }

        private void SetSuffixIndices(SuffixTreeNode node, int value)
        {
            if (node.Children.Count == 0)
            {
                node.SuffixIndex = _text.Length - value;
                return;
            }

            foreach (var child in node.Children.Values)
            {
                SetSuffixIndices(child, value + child.Length);
            }
        }

        public List<int> SearchPattern(string pattern)
        {
            var positions = new List<int>();
            if (string.IsNullOrEmpty(pattern)) return positions;

            SuffixTreeNode currentNode = _root;
            int patternIndex = 0;

            while (patternIndex < pattern.Length)
            {
                char currentChar = pattern[patternIndex];
                if (!currentNode.Children.ContainsKey(currentChar))
                    return positions;

                SuffixTreeNode nextNode = currentNode.Children[currentChar];
                int edgeLength = Math.Min(nextNode.Length, pattern.Length - patternIndex);

                for (int i = 0; i < edgeLength; i++)
                {
                    if (patternIndex >= pattern.Length ||
                        nextNode.Start + i >= _text.Length ||
                        _text[nextNode.Start + i] != pattern[patternIndex])
                        return positions;
                    patternIndex++;
                }

                currentNode = nextNode;
            }

            CollectAllPositions(currentNode, positions);
            return positions;
        }

        private void CollectAllPositions(SuffixTreeNode node, List<int> positions)
        {
            if (node.SuffixIndex != -1)
            {
                positions.Add(node.SuffixIndex);
            }

            foreach (var child in node.Children.Values)
            {
                CollectAllPositions(child, positions);
            }
        }

        public string FindLongestRepeatedSubstring()
        {
            var result = new StringBuilder();
            FindLongestRepeatedSubstring(_root, new StringBuilder(), result);
            return result.ToString();
        }

        private void FindLongestRepeatedSubstring(SuffixTreeNode node, StringBuilder current, StringBuilder result)
        {
            if (node != _root && node.Children.Count > 1)
            {
                if (current.Length > result.Length)
                {
                    result.Clear();
                    result.Append(current.ToString());
                }
            }

            foreach (var kvp in node.Children)
            {
                var child = kvp.Value;

                for (int i = 0; i < child.Length && child.Start + i < _text.Length; i++)
                {
                    current.Append(_text[child.Start + i]);
                }

                FindLongestRepeatedSubstring(child, current, result);

                for (int i = 0; i < child.Length; i++)
                {
                    if (current.Length > 0)
                        current.Length--;
                }
            }
        }

        public void PrintTree()
        {
            Console.WriteLine("Суффиксное дерево для: " + _text.Replace("$", ""));
            PrintTree(_root, 0);
        }

        private void PrintTree(SuffixTreeNode node, int depth)
        {
            foreach (var kvp in node.Children)
            {
                var child = kvp.Value;

                string edge = GetSafeSubstring(child.Start, child.Length);
                string suffixInfo = child.SuffixIndex != -1 ? $" [Лист: {child.SuffixIndex}]" : "";
                string nodeInfo = child.Children.Count > 0 ? $" [Детей: {child.Children.Count}]" : "";

                Console.WriteLine($"{new string(' ', depth * 2)}--{edge}{suffixInfo}{nodeInfo}");
                PrintTree(child, depth + 1);
            }
        }

        private string GetSafeSubstring(int start, int length)
        {
            if (start < 0 || start >= _text.Length)
                return "?";

            length = Math.Min(length, _text.Length - start);
            return _text.Substring(start, length).Replace("$", "◄");
        }
    }

    public class SimpleSuffixTree
    {
        private class Node
        {
            public Dictionary<char, Node> Children { get; } = new Dictionary<char, Node>();
            public List<int> Indexes { get; } = new List<int>();
        }

        private readonly Node _root = new Node();
        private readonly string _text;

        public SimpleSuffixTree(string text)
        {
            _text = text;
            BuildTree();
        }

        private void BuildTree()
        {
            for (int i = 0; i < _text.Length; i++)
            {
                AddSuffix(i, _root);
            }
        }

        private void AddSuffix(int suffixStart, Node node)
        {
            node.Indexes.Add(suffixStart);

            if (suffixStart < _text.Length)
            {
                char firstChar = _text[suffixStart];

                if (!node.Children.ContainsKey(firstChar))
                {
                    node.Children[firstChar] = new Node();
                }

                AddSuffix(suffixStart + 1, node.Children[firstChar]);
            }
        }

        public List<int> SearchPattern(string pattern)
        {
            return SearchPattern(pattern, _root);
        }

        private List<int> SearchPattern(string pattern, Node node)
        {
            if (string.IsNullOrEmpty(pattern))
                return node.Indexes;

            if (!node.Children.ContainsKey(pattern[0]))
                return new List<int>();

            return SearchPattern(pattern.Substring(1), node.Children[pattern[0]]);
        }

        public void PrintTree()
        {
            Console.WriteLine("Простое суффиксное дерево:");
            PrintTree(_root, 0);
        }

        private void PrintTree(Node node, int depth)
        {
            foreach (var kvp in node.Children)
            {
                Console.WriteLine($"{new string(' ', depth * 2)}--{kvp.Key} [индексы: {string.Join(",", kvp.Value.Indexes)}]");
                PrintTree(kvp.Value, depth + 1);
            }
        }
    }

    public class AdvancedSuffixOperations
    {
        public static string FindLongestCommonSubstring(string text1, string text2)
        {
            int maxLen = 0;
            string result = "";

            for (int i = 0; i < text1.Length; i++)
            {
                for (int j = 0; j < text2.Length; j++)
                {
                    int len = 0;
                    while (i + len < text1.Length &&
                           j + len < text2.Length &&
                           text1[i + len] == text2[j + len])
                    {
                        len++;
                    }
                    if (len > maxLen)
                    {
                        maxLen = len;
                        result = text1.Substring(i, len);
                    }
                }
            }

            return result;
        }

        public static List<string> FindAllRepeatedSubstrings(string text, int minLength = 2)
        {
            var result = new HashSet<string>();

            for (int len = minLength; len <= text.Length / 2; len++)
            {
                var seen = new HashSet<string>();
                for (int i = 0; i <= text.Length - len; i++)
                {
                    string substring = text.Substring(i, len);
                    if (!seen.Contains(substring))
                    {
                        seen.Add(substring);

                        int count = 0;
                        for (int j = 0; j <= text.Length - len; j++)
                        {
                            if (text.Substring(j, len) == substring)
                            {
                                count++;
                                if (count > 1)
                                {
                                    result.Add(substring);
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            return result.OrderByDescending(s => s.Length).ThenBy(s => s).ToList();
        }
    }

    public class SuffixTreePerformanceTester
    {
        public static void TestPerformance(int textLength = 10000)
        {
            Console.WriteLine($"=== ТЕСТ ПРОИЗВОДИТЕЛЬНОСТИ (n = {textLength}) ===");

            var random = new Random();
            var textBuilder = new StringBuilder(textLength);
            for (int i = 0; i < textLength; i++)
            {
                textBuilder.Append((char)('a' + random.Next(0, 26)));
            }
            string text = textBuilder.ToString();

            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var simpleTree = new SimpleSuffixTree(text);
            var simpleTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Построение простого дерева: {simpleTime} мс");

            stopwatch.Restart();
            int patternCount = 50;
            int totalMatches = 0;

            for (int i = 0; i < patternCount; i++)
            {
                int patternLength = random.Next(3, 10);
                int startPos = random.Next(0, textLength - patternLength);
                string pattern = text.Substring(startPos, patternLength);

                var matches = simpleTree.SearchPattern(pattern);
                totalMatches += matches.Count;
            }

            var searchTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"{patternCount} поисков в простом дереве: {searchTime} мс");
            Console.WriteLine($"Всего найдено совпадений: {totalMatches}");

            stopwatch.Restart();
            var repeated = AdvancedSuffixOperations.FindAllRepeatedSubstrings(text.Substring(0, Math.Min(1000, text.Length)), 3);
            var repeatTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Найдено повторяющихся подстрок: {repeated.Count}");
            Console.WriteLine($"Время поиска: {repeatTime} мс");

            if (repeated.Count > 0)
            {
                Console.WriteLine($"Самая длинная: '{repeated[0]}' (длина: {repeated[0].Length})");
            }

            long memoryUsed = GC.GetTotalMemory(true);
            Console.WriteLine($"Использование памяти: {memoryUsed / 1024} КБ");
        }
    }

    public static class ExtensionMethods
    {
        public static string GetText(this SuffixTree tree)
        {
            return "implementation_required";
        }
    }

    public enum UnionStrategy
    {
        ByRank,
        BySize
    }

    public class UnionFind
    {
        private int[] _parent;
        private int[] _rank;
        private int[] _size;
        private int _components;
        private readonly UnionStrategy _strategy;

        public int Components => _components;
        public int Count => _parent.Length;

        public UnionFind(int n, UnionStrategy strategy = UnionStrategy.ByRank)
        {
            if (n <= 0) throw new ArgumentException("Size must be positive");

            _parent = new int[n];
            _rank = new int[n];
            _size = new int[n];
            _strategy = strategy;
            _components = n;

            for (int i = 0; i < n; i++)
            {
                _parent[i] = i;
                _size[i] = 1;
                _rank[i] = 0;
            }
        }

        public int Find(int x)
        {
            if (x < 0 || x >= _parent.Length)
                throw new ArgumentOutOfRangeException(nameof(x));

            if (_parent[x] != x)
                _parent[x] = Find(_parent[x]);

            return _parent[x];
        }

        public int FindIterative(int x)
        {
            if (x < 0 || x >= _parent.Length)
                throw new ArgumentOutOfRangeException(nameof(x));

            int root = x;
            while (root != _parent[root])
                root = _parent[root];

            while (x != root)
            {
                int next = _parent[x];
                _parent[x] = root;
                x = next;
            }

            return root;
        }

        public bool Union(int x, int y)
        {
            int rootX = Find(x);
            int rootY = Find(y);

            if (rootX == rootY)
                return false;

            if (_strategy == UnionStrategy.ByRank)
                UnionByRank(rootX, rootY);
            else
                UnionBySize(rootX, rootY);

            _components--;
            return true;
        }

        private void UnionByRank(int rootX, int rootY)
        {
            if (_rank[rootX] < _rank[rootY])
            {
                _parent[rootX] = rootY;
            }
            else if (_rank[rootX] > _rank[rootY])
            {
                _parent[rootY] = rootX;
            }
            else
            {
                _parent[rootY] = rootX;
                _rank[rootX]++;
            }
        }

        private void UnionBySize(int rootX, int rootY)
        {
            if (_size[rootX] < _size[rootY])
            {
                _parent[rootX] = rootY;
                _size[rootY] += _size[rootX];
            }
            else
            {
                _parent[rootY] = rootX;
                _size[rootX] += _size[rootY];
            }
        }

        public bool Connected(int x, int y)
        {
            return Find(x) == Find(y);
        }

        public int GetComponentSize(int x)
        {
            int root = Find(x);
            return _strategy == UnionStrategy.BySize ? _size[root] : -1;
        }

        public Dictionary<int, List<int>> GetAllComponents()
        {
            var components = new Dictionary<int, List<int>>();

            for (int i = 0; i < _parent.Length; i++)
            {
                int root = Find(i);
                if (!components.ContainsKey(root))
                    components[root] = new List<int>();
                components[root].Add(i);
            }

            return components;
        }

        public int GetLargestComponentSize()
        {
            if (_strategy != UnionStrategy.BySize)
                throw new InvalidOperationException("Available only for union by size");

            return _size.Max();
        }

        public void Reset()
        {
            _components = _parent.Length;
            for (int i = 0; i < _parent.Length; i++)
            {
                _parent[i] = i;
                _size[i] = 1;
                _rank[i] = 0;
            }
        }

        public void PrintStats()
        {
            var components = GetAllComponents();
            Console.WriteLine($"Всего компонент: {_components}");
            Console.WriteLine($"Всего элементов: {Count}");

            if (_strategy == UnionStrategy.BySize)
            {
                Console.WriteLine($"Размер наибольшей компоненты: {GetLargestComponentSize()}");
                Console.WriteLine($"Размер наименьшей компоненты: {components.Values.Min(c => c.Count)}");
            }

            var componentSizes = components.Values.Select(c => c.Count).OrderByDescending(s => s).Take(5);
            Console.WriteLine($"Топ-5 размеров компонент: [{string.Join(", ", componentSizes)}]");
        }
    }

    public class UndoableUnionFind
    {
        private int[] _parent;
        private int[] _rank;
        private int[] _size;
        private int _components;
        private readonly Stack<Operation> _operations = new Stack<Operation>();

        private class Operation
        {
            public int Type { get; }
            public int Index { get; }
            public int OldValue { get; }
            public int NewValue { get; }

            public Operation(int type, int index, int oldValue, int newValue)
            {
                Type = type;
                Index = index;
                OldValue = oldValue;
                NewValue = newValue;
            }
        }

        public UndoableUnionFind(int n)
        {
            _parent = new int[n];
            _rank = new int[n];
            _size = new int[n];
            _components = n;

            for (int i = 0; i < n; i++)
            {
                _parent[i] = i;
                _size[i] = 1;
                _rank[i] = 0;
            }
        }

        public int Find(int x)
        {
            if (_parent[x] != x)
                _parent[x] = Find(_parent[x]);
            return _parent[x];
        }

        public bool Union(int x, int y)
        {
            int rootX = Find(x);
            int rootY = Find(y);

            if (rootX == rootY)
                return false;

            SaveState();

            if (_rank[rootX] < _rank[rootY])
            {
                _parent[rootX] = rootY;
                _size[rootY] += _size[rootX];
            }
            else if (_rank[rootX] > _rank[rootY])
            {
                _parent[rootY] = rootX;
                _size[rootX] += _size[rootY];
            }
            else
            {
                _parent[rootY] = rootX;
                _rank[rootX]++;
                _size[rootX] += _size[rootY];
            }

            _components--;
            return true;
        }

        private void SaveState()
        {
            _operations.Push(new Operation(0, -1, -1, -1));
        }

        public void Undo()
        {
            if (_operations.Count == 0)
                return;

            Reset();
        }

        public void Reset()
        {
            _components = _parent.Length;
            for (int i = 0; i < _parent.Length; i++)
            {
                _parent[i] = i;
                _size[i] = 1;
                _rank[i] = 0;
            }
            _operations.Clear();
        }

        public bool Connected(int x, int y) => Find(x) == Find(y);
        public int Components => _components;
    }

    public class DynamicGraph
    {
        private readonly UnionFind _unionFind;
        private readonly List<(int, int)> _edges = new List<(int, int)>();
        private readonly bool[,] _adjacencyMatrix;
        private readonly int _vertices;

        public DynamicGraph(int vertices, UnionStrategy strategy = UnionStrategy.ByRank)
        {
            _vertices = vertices;
            _unionFind = new UnionFind(vertices, strategy);
            _adjacencyMatrix = new bool[vertices, vertices];
        }

        public void AddEdge(int u, int v)
        {
            if (u < 0 || u >= _vertices || v < 0 || v >= _vertices)
                throw new ArgumentOutOfRangeException();

            if (_adjacencyMatrix[u, v]) return;

            _edges.Add((u, v));
            _adjacencyMatrix[u, v] = true;
            _adjacencyMatrix[v, u] = true;

            _unionFind.Union(u, v);
        }

        public void RemoveEdge(int u, int v)
        {
            if (!_adjacencyMatrix[u, v]) return;

            _adjacencyMatrix[u, v] = false;
            _adjacencyMatrix[v, u] = false;

            RebuildUnionFind();
        }

        private void RebuildUnionFind()
        {
            _unionFind.Reset();

            foreach (var (u, v) in _edges)
            {
                if (_adjacencyMatrix[u, v])
                    _unionFind.Union(u, v);
            }
        }

        public bool AreConnected(int u, int v) => _unionFind.Connected(u, v);
        public int GetConnectedComponents() => _unionFind.Components;
        public Dictionary<int, List<int>> GetAllComponents() => _unionFind.GetAllComponents();

        public void AddRandomEdges(int count)
        {
            var random = new Random();
            for (int i = 0; i < count; i++)
            {
                int u = random.Next(_vertices);
                int v = random.Next(_vertices);
                AddEdge(u, v);
            }
        }

        public void PrintGraphInfo()
        {
            Console.WriteLine($"Вершины: {_vertices}, Рёбра: {_edges.Count}");
            Console.WriteLine($"Компоненты связности: {_unionFind.Components}");

            var components = _unionFind.GetAllComponents();
            var largestComponent = components.Values.OrderByDescending(c => c.Count).First();
            Console.WriteLine($"Наибольшая компонента: {largestComponent.Count} вершин");
        }
    }

    public class UnionFindApplications
    {
        public static bool HasCycle(List<(int, int)> edges, int vertices)
        {
            var uf = new UnionFind(vertices);

            foreach (var (u, v) in edges)
            {
                if (!uf.Union(u, v))
                    return true;
            }

            return false;
        }

        public static int CountConnectedComponents(List<(int, int)> edges, int vertices)
        {
            var uf = new UnionFind(vertices);

            foreach (var (u, v) in edges)
            {
                uf.Union(u, v);
            }

            return uf.Components;
        }

        public static List<(int, int, int)> KruskalMST(List<(int u, int v, int weight)> edges, int vertices)
        {
            var sortedEdges = edges.OrderBy(e => e.weight).ToList();
            var mst = new List<(int, int, int)>();
            var uf = new UnionFind(vertices);

            foreach (var edge in sortedEdges)
            {
                if (uf.Union(edge.u, edge.v))
                {
                    mst.Add(edge);
                    if (mst.Count == vertices - 1)
                        break;
                }
            }

            return mst;
        }

        public static List<(int, int)> FindBridges(List<(int, int)> edges, int vertices)
        {
            var bridges = new List<(int, int)>();

            for (int i = 0; i < edges.Count; i++)
            {
                var uf = new UnionFind(vertices);

                for (int j = 0; j < edges.Count; j++)
                {
                    if (i != j)
                    {
                        uf.Union(edges[j].Item1, edges[j].Item2);
                    }
                }

                if (!uf.Connected(edges[i].Item1, edges[i].Item2))
                {
                    bridges.Add(edges[i]);
                }
            }

            return bridges;
        }
    }

    public class UnionFindPerformanceTester
    {
        public static void TestUnionFindPerformance(int operations = 1000000)
        {
            Console.WriteLine($"=== ТЕСТ ПРОИЗВОДИТЕЛЬНОСТИ UNION-FIND ({operations} операций) ===");

            TestStrategy(UnionStrategy.ByRank, "By Rank", operations);
            TestStrategy(UnionStrategy.BySize, "By Size", operations);
        }

        private static void TestStrategy(UnionStrategy strategy, string name, int operations)
        {
            Console.WriteLine($"\n--- Стратегия: {name} ---");

            int n = Math.Min(operations * 2, 2000000);
            var unionFind = new UnionFind(n, strategy);
            var random = new Random();

            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            for (int i = 0; i < operations; i++)
            {
                int a = random.Next(n);
                int b = random.Next(n);

                if (random.NextDouble() < 0.7)
                {
                    unionFind.Union(a, b);
                }
                else
                {
                    unionFind.Find(a);
                }
            }

            var elapsed = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Время выполнения: {elapsed} мс");
            Console.WriteLine($"Операций в секунду: {operations * 1000L / elapsed}");
            Console.WriteLine($"Финальное количество компонент: {unionFind.Components}");

            long memory = GC.GetTotalMemory(true);
            Console.WriteLine($"Использование памяти: {memory / 1024 / 1024} МБ");
        }

        public static void TestDynamicGraphPerformance()
        {
            Console.WriteLine("\n=== ТЕСТ ДИНАМИЧЕСКОГО ГРАФА ===");

            int vertices = 10000;
            int edges = 50000;

            var graphByRank = new DynamicGraph(vertices, UnionStrategy.ByRank);
            var graphBySize = new DynamicGraph(vertices, UnionStrategy.BySize);

            var random = new Random();

            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            graphByRank.AddRandomEdges(edges);
            var timeByRank = stopwatch.ElapsedMilliseconds;

            stopwatch.Restart();
            graphBySize.AddRandomEdges(edges);
            var timeBySize = stopwatch.ElapsedMilliseconds;

            Console.WriteLine($"Добавление {edges} рёбер:");
            Console.WriteLine($"  By Rank: {timeByRank} мс");
            Console.WriteLine($"  By Size: {timeBySize} мс");

            int queries = 10000;
            stopwatch.Restart();
            for (int i = 0; i < queries; i++)
            {
                int u = random.Next(vertices);
                int v = random.Next(vertices);
                graphByRank.AreConnected(u, v);
            }
            var queryTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"{queries} запросов связности: {queryTime} мс");
        }
    }

    public class BTree<TKey, TValue> where TKey : IComparable<TKey>
    {
        private readonly int _minDegree;
        private readonly int _maxKeys;
        private readonly int _minKeys;
        private BTreeNode _root;
        private readonly string _storagePath;
        private long _nextNodeId;
        private readonly Dictionary<long, BTreeNode> _nodeCache;
        private readonly int _cacheCapacity;
        private bool _isInitialized;

        private class BTreeNode
        {
            public long Id { get; set; }
            public bool IsLeaf { get; set; }
            public List<TKey> Keys { get; set; }
            public List<TValue> Values { get; set; }
            public List<long> Children { get; set; }
            public int KeyCount => Keys.Count;
            public bool IsFull => KeyCount >= (2 * (Keys.Capacity / 2) - 1);
            public bool IsModified { get; set; }

            public BTreeNode(long id, bool isLeaf, int maxKeys)
            {
                Id = id;
                IsLeaf = isLeaf;
                Keys = new List<TKey>(maxKeys);
                Values = new List<TValue>(maxKeys);
                Children = new List<long>(maxKeys + 1);
                IsModified = true;
            }

            public override string ToString()
            {
                return $"Node {Id}: [{string.Join(", ", Keys)}] (Leaf: {IsLeaf})";
            }
        }

        public BTree(int minDegree = 3, string storagePath = null, int cacheCapacity = 1000)
        {
            if (minDegree < 2)
                throw new ArgumentException("Min degree must be at least 2");

            _minDegree = minDegree;
            _maxKeys = 2 * minDegree - 1;
            _minKeys = minDegree - 1;
            _storagePath = storagePath ?? Path.Combine(Directory.GetCurrentDirectory(), "btree_storage");
            _nodeCache = new Dictionary<long, BTreeNode>();
            _cacheCapacity = cacheCapacity;
            _nextNodeId = 1;
            _isInitialized = false;

            InitializeStorage();
            InitializeRoot();
        }

        private void InitializeStorage()
        {
            try
            {
                if (!Directory.Exists(_storagePath))
                {
                    Directory.CreateDirectory(_storagePath);
                    Console.WriteLine($"Created storage directory: {_storagePath}");
                }

                var metadataPath = Path.Combine(_storagePath, "metadata.btree");
                if (File.Exists(metadataPath))
                {
                    LoadMetadata();
                    _isInitialized = true;
                    Console.WriteLine("Loaded existing B-Tree from disk");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Warning: Could not initialize storage: {ex.Message}");
            }
        }

        private void InitializeRoot()
        {
            if (!_isInitialized)
            {
                _root = CreateNewNode(true);
                _root.IsModified = true;
                SaveNode(_root);
                SaveMetadata();
                _isInitialized = true;
            }
            else
            {
                _root = LoadNode(1);
            }
        }

        public TValue Search(TKey key)
        {
            if (!_isInitialized)
                throw new InvalidOperationException("B-Tree not initialized");

            return Search(_root, key);
        }

        public void Insert(TKey key, TValue value)
        {
            if (!_isInitialized)
                throw new InvalidOperationException("B-Tree not initialized");

            var root = _root;

            if (root.IsFull)
            {
                var newRoot = CreateNewNode(false);
                newRoot.Children.Add(root.Id);
                SplitChild(newRoot, 0, root);
                _root = newRoot;
                SaveNode(_root);
                root = _root;
            }

            InsertNonFull(root, key, value);
        }

        public bool Delete(TKey key)
        {
            if (!_isInitialized)
                throw new InvalidOperationException("B-Tree not initialized");

            var result = Delete(_root, key);
            if (result && _root.KeyCount == 0 && !_root.IsLeaf)
            {
                var oldRoot = _root;
                _root = LoadNode(_root.Children[0]);
                RemoveNodeFromStorage(oldRoot.Id);
            }
            return result;
        }

        public bool Contains(TKey key)
        {
            try
            {
                Search(key);
                return true;
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
        }

        public void Update(TKey key, TValue value)
        {
            if (!_isInitialized)
                throw new InvalidOperationException("B-Tree not initialized");

            var node = _root;
            while (node != null)
            {
                int i = 0;
                while (i < node.KeyCount && key.CompareTo(node.Keys[i]) > 0)
                    i++;

                if (i < node.KeyCount && key.CompareTo(node.Keys[i]) == 0)
                {
                    node.Values[i] = value;
                    node.IsModified = true;
                    SaveNode(node);
                    return;
                }

                if (node.IsLeaf)
                    break;

                node = LoadNode(node.Children[i]);
            }

            throw new KeyNotFoundException($"Key {key} not found");
        }

        public List<KeyValuePair<TKey, TValue>> RangeSearch(TKey start, TKey end)
        {
            if (!_isInitialized)
                throw new InvalidOperationException("B-Tree not initialized");

            var results = new List<KeyValuePair<TKey, TValue>>();
            RangeSearch(_root, start, end, results);
            return results;
        }

        public TKey FindMin()
        {
            if (!_isInitialized)
                throw new InvalidOperationException("B-Tree not initialized");

            var node = _root;
            while (!node.IsLeaf)
            {
                node = LoadNode(node.Children[0]);
            }
            return node.Keys[0];
        }

        public TKey FindMax()
        {
            if (!_isInitialized)
                throw new InvalidOperationException("B-Tree not initialized");

            var node = _root;
            while (!node.IsLeaf)
            {
                node = LoadNode(node.Children[node.Children.Count - 1]);
            }
            return node.Keys[node.Keys.Count - 1];
        }

        public BTreeStats GetStats()
        {
            if (!_isInitialized)
                throw new InvalidOperationException("B-Tree not initialized");

            var stats = new BTreeStats();
            CollectStats(_root, 0, stats);
            return stats;
        }

        public void FlushToDisk()
        {
            if (!_isInitialized) return;

            foreach (var node in _nodeCache.Values.Where(n => n.IsModified))
            {
                SaveNode(node);
            }
            SaveMetadata();
        }

        public void LoadFromDisk()
        {
            LoadMetadata();
            _root = LoadNode(1);
            _isInitialized = true;
        }

        public void Optimize()
        {
            if (!_isInitialized)
                throw new InvalidOperationException("B-Tree not initialized");

            var allNodes = GetAllNodes();
            _nodeCache.Clear();

            long newId = 1;
            var idMapping = new Dictionary<long, long>();

            foreach (var node in allNodes)
            {
                idMapping[node.Id] = newId;
                node.Id = newId++;
                node.IsModified = true;
                _nodeCache[node.Id] = node;
            }

            foreach (var node in allNodes)
            {
                for (int i = 0; i < node.Children.Count; i++)
                {
                    node.Children[i] = idMapping[node.Children[i]];
                }
                SaveNode(node);
            }

            _root = _nodeCache[1];
            SaveMetadata();
        }

        public void PrintTree()
        {
            if (!_isInitialized)
            {
                Console.WriteLine("B-Tree not initialized");
                return;
            }

            PrintTree(_root, 0, "");
        }

        private TValue Search(BTreeNode node, TKey key)
        {
            int i = 0;
            while (i < node.KeyCount && key.CompareTo(node.Keys[i]) > 0)
                i++;

            if (i < node.KeyCount && key.CompareTo(node.Keys[i]) == 0)
                return node.Values[i];

            if (node.IsLeaf)
                throw new KeyNotFoundException($"Key {key} not found");

            var childNode = LoadNode(node.Children[i]);
            return Search(childNode, key);
        }

        private void InsertNonFull(BTreeNode node, TKey key, TValue value)
        {
            int i = node.KeyCount - 1;

            if (node.IsLeaf)
            {
                node.Keys.Add(default(TKey));
                node.Values.Add(default(TValue));

                while (i >= 0 && key.CompareTo(node.Keys[i]) < 0)
                {
                    node.Keys[i + 1] = node.Keys[i];
                    node.Values[i + 1] = node.Values[i];
                    i--;
                }

                node.Keys[i + 1] = key;
                node.Values[i + 1] = value;
                node.IsModified = true;
                SaveNode(node);
            }
            else
            {
                while (i >= 0 && key.CompareTo(node.Keys[i]) < 0)
                {
                    i--;
                }
                i++;

                var child = LoadNode(node.Children[i]);
                if (child.KeyCount >= _maxKeys)
                {
                    SplitChild(node, i, child);
                    if (key.CompareTo(node.Keys[i]) > 0)
                    {
                        i++;
                        child = LoadNode(node.Children[i]);
                    }
                }

                InsertNonFull(child, key, value);
            }
        }

        private void SplitChild(BTreeNode parent, int index, BTreeNode child)
        {
            var newChild = CreateNewNode(child.IsLeaf);

            int splitIndex = child.KeyCount / 2;
            var middleKey = child.Keys[splitIndex];
            var middleValue = child.Values[splitIndex];

            for (int i = splitIndex + 1; i < child.KeyCount; i++)
            {
                newChild.Keys.Add(child.Keys[i]);
                newChild.Values.Add(child.Values[i]);
            }

            if (!child.IsLeaf)
            {
                for (int i = splitIndex + 1; i <= child.KeyCount; i++)
                {
                    newChild.Children.Add(child.Children[i]);
                }
                child.Children.RemoveRange(splitIndex + 1, child.Children.Count - splitIndex - 1);
            }

            child.Keys.RemoveRange(splitIndex, child.KeyCount - splitIndex);
            child.Values.RemoveRange(splitIndex, child.Values.Count - splitIndex);

            parent.Keys.Insert(index, middleKey);
            parent.Values.Insert(index, middleValue);
            parent.Children.Insert(index + 1, newChild.Id);

            parent.IsModified = true;
            child.IsModified = true;
            newChild.IsModified = true;

            SaveNode(parent);
            SaveNode(child);
            SaveNode(newChild);
        }

        private bool Delete(BTreeNode node, TKey key)
        {
            int idx = FindKey(node, key);

            if (idx < node.KeyCount && node.Keys[idx].CompareTo(key) == 0)
            {
                if (node.IsLeaf)
                {
                    RemoveFromLeaf(node, idx);
                }
                else
                {
                    RemoveFromNonLeaf(node, idx);
                }
                return true;
            }

            if (node.IsLeaf)
            {
                return false;
            }

            bool flag = (idx == node.KeyCount);
            var child = LoadNode(node.Children[idx]);

            if (child.KeyCount < _minKeys)
            {
                FillChild(node, idx);
            }

            if (flag && idx > node.KeyCount)
            {
                return Delete(LoadNode(node.Children[idx - 1]), key);
            }
            else
            {
                return Delete(LoadNode(node.Children[idx]), key);
            }
        }

        private void RemoveFromLeaf(BTreeNode node, int idx)
        {
            node.Keys.RemoveAt(idx);
            node.Values.RemoveAt(idx);
            node.IsModified = true;
            SaveNode(node);
        }

        private void RemoveFromNonLeaf(BTreeNode node, int idx)
        {
            TKey key = node.Keys[idx];

            var leftChild = LoadNode(node.Children[idx]);
            var rightChild = LoadNode(node.Children[idx + 1]);

            if (leftChild.KeyCount >= _minKeys)
            {
                var predecessor = GetPredecessor(leftChild);
                node.Keys[idx] = predecessor.Key;
                node.Values[idx] = predecessor.Value;
                node.IsModified = true;
                Delete(leftChild, predecessor.Key);
                SaveNode(node);
            }
            else if (rightChild.KeyCount >= _minKeys)
            {
                var successor = GetSuccessor(rightChild);
                node.Keys[idx] = successor.Key;
                node.Values[idx] = successor.Value;
                node.IsModified = true;
                Delete(rightChild, successor.Key);
                SaveNode(node);
            }
            else
            {
                MergeChildren(node, idx);
                Delete(leftChild, key);
            }
        }

        private void FillChild(BTreeNode parent, int idx)
        {
            if (idx != 0 && LoadNode(parent.Children[idx - 1]).KeyCount >= _minKeys)
            {
                BorrowFromLeft(parent, idx);
            }
            else if (idx != parent.KeyCount && LoadNode(parent.Children[idx + 1]).KeyCount >= _minKeys)
            {
                BorrowFromRight(parent, idx);
            }
            else
            {
                if (idx != parent.KeyCount)
                {
                    MergeChildren(parent, idx);
                }
                else
                {
                    MergeChildren(parent, idx - 1);
                }
            }
        }

        private void BorrowFromLeft(BTreeNode parent, int idx)
        {
            var child = LoadNode(parent.Children[idx]);
            var leftSibling = LoadNode(parent.Children[idx - 1]);

            child.Keys.Insert(0, parent.Keys[idx - 1]);
            child.Values.Insert(0, parent.Values[idx - 1]);

            if (!child.IsLeaf)
            {
                child.Children.Insert(0, leftSibling.Children[leftSibling.Children.Count - 1]);
                leftSibling.Children.RemoveAt(leftSibling.Children.Count - 1);
            }

            parent.Keys[idx - 1] = leftSibling.Keys[leftSibling.Keys.Count - 1];
            parent.Values[idx - 1] = leftSibling.Values[leftSibling.Values.Count - 1];

            leftSibling.Keys.RemoveAt(leftSibling.Keys.Count - 1);
            leftSibling.Values.RemoveAt(leftSibling.Values.Count - 1);

            parent.IsModified = true;
            child.IsModified = true;
            leftSibling.IsModified = true;

            SaveNode(parent);
            SaveNode(child);
            SaveNode(leftSibling);
        }

        private void BorrowFromRight(BTreeNode parent, int idx)
        {
            var child = LoadNode(parent.Children[idx]);
            var rightSibling = LoadNode(parent.Children[idx + 1]);

            child.Keys.Add(parent.Keys[idx]);
            child.Values.Add(parent.Values[idx]);

            if (!child.IsLeaf)
            {
                child.Children.Add(rightSibling.Children[0]);
                rightSibling.Children.RemoveAt(0);
            }

            parent.Keys[idx] = rightSibling.Keys[0];
            parent.Values[idx] = rightSibling.Values[0];

            rightSibling.Keys.RemoveAt(0);
            rightSibling.Values.RemoveAt(0);

            parent.IsModified = true;
            child.IsModified = true;
            rightSibling.IsModified = true;

            SaveNode(parent);
            SaveNode(child);
            SaveNode(rightSibling);
        }

        private void MergeChildren(BTreeNode parent, int idx)
        {
            var leftChild = LoadNode(parent.Children[idx]);
            var rightChild = LoadNode(parent.Children[idx + 1]);

            leftChild.Keys.Add(parent.Keys[idx]);
            leftChild.Values.Add(parent.Values[idx]);

            leftChild.Keys.AddRange(rightChild.Keys);
            leftChild.Values.AddRange(rightChild.Values);

            if (!leftChild.IsLeaf)
            {
                leftChild.Children.AddRange(rightChild.Children);
            }

            parent.Keys.RemoveAt(idx);
            parent.Values.RemoveAt(idx);
            parent.Children.RemoveAt(idx + 1);

            parent.IsModified = true;
            leftChild.IsModified = true;

            SaveNode(parent);
            SaveNode(leftChild);
            RemoveNodeFromStorage(rightChild.Id);
        }

        private int FindKey(BTreeNode node, TKey key)
        {
            int idx = 0;
            while (idx < node.KeyCount && node.Keys[idx].CompareTo(key) < 0)
            {
                idx++;
            }
            return idx;
        }

        private KeyValuePair<TKey, TValue> GetPredecessor(BTreeNode node)
        {
            while (!node.IsLeaf)
            {
                node = LoadNode(node.Children[node.Children.Count - 1]);
            }
            return new KeyValuePair<TKey, TValue>(
                node.Keys[node.Keys.Count - 1],
                node.Values[node.Values.Count - 1]);
        }

        private KeyValuePair<TKey, TValue> GetSuccessor(BTreeNode node)
        {
            while (!node.IsLeaf)
            {
                node = LoadNode(node.Children[0]);
            }
            return new KeyValuePair<TKey, TValue>(node.Keys[0], node.Values[0]);
        }

        private void RangeSearch(BTreeNode node, TKey start, TKey end, List<KeyValuePair<TKey, TValue>> results)
        {
            int i = 0;
            while (i < node.KeyCount && start.CompareTo(node.Keys[i]) > 0)
                i++;

            while (i < node.KeyCount && end.CompareTo(node.Keys[i]) >= 0)
            {
                if (start.CompareTo(node.Keys[i]) <= 0)
                {
                    results.Add(new KeyValuePair<TKey, TValue>(node.Keys[i], node.Values[i]));
                }
                i++;
            }

            if (!node.IsLeaf)
            {
                for (int j = 0; j <= node.KeyCount; j++)
                {
                    if (j < node.Children.Count)
                    {
                        var child = LoadNode(node.Children[j]);
                        RangeSearch(child, start, end, results);
                    }
                }
            }
        }

        private void PrintTree(BTreeNode node, int depth, string prefix)
        {
            Console.WriteLine($"{prefix}Level {depth}: {node}");

            if (!node.IsLeaf)
            {
                for (int i = 0; i < node.Children.Count; i++)
                {
                    var childPrefix = $"{prefix}  ";
                    if (i < node.KeyCount)
                    {
                        Console.WriteLine($"{childPrefix}Key: {node.Keys[i]}");
                    }
                    var child = LoadNode(node.Children[i]);
                    PrintTree(child, depth + 1, childPrefix);
                }
            }
        }

        private BTreeNode CreateNewNode(bool isLeaf)
        {
            var node = new BTreeNode(_nextNodeId++, isLeaf, _maxKeys);
            _nodeCache[node.Id] = node;
            ManageCache();
            return node;
        }

        private BTreeNode LoadNode(long id)
        {
            if (_nodeCache.TryGetValue(id, out var node))
                return node;

            var filePath = Path.Combine(_storagePath, $"{id}.node");
            if (!File.Exists(filePath))
            {
                node = new BTreeNode(id, true, _maxKeys);
                _nodeCache[id] = node;
                return node;
            }

            try
            {
                using var stream = new FileStream(filePath, FileMode.Open);
                using var reader = new BinaryReader(stream);

                var isLeaf = reader.ReadBoolean();
                var keyCount = reader.ReadInt32();

                node = new BTreeNode(id, isLeaf, _maxKeys);

                for (int i = 0; i < keyCount; i++)
                {
                    var key = DeserializeKey(reader);
                    var value = DeserializeValue(reader);
                    node.Keys.Add(key);
                    node.Values.Add(value);
                }

                if (!isLeaf)
                {
                    for (int i = 0; i <= keyCount; i++)
                    {
                        node.Children.Add(reader.ReadInt64());
                    }
                }

                _nodeCache[id] = node;
                ManageCache();

                return node;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading node {id}: {ex.Message}");
                node = new BTreeNode(id, true, _maxKeys);
                _nodeCache[id] = node;
                return node;
            }
        }

        private void SaveNode(BTreeNode node)
        {
            try
            {
                var filePath = Path.Combine(_storagePath, $"{node.Id}.node");

                Directory.CreateDirectory(Path.GetDirectoryName(filePath));

                using var stream = new FileStream(filePath, FileMode.Create);
                using var writer = new BinaryWriter(stream);

                writer.Write(node.IsLeaf);
                writer.Write(node.KeyCount);

                for (int i = 0; i < node.KeyCount; i++)
                {
                    SerializeKey(writer, node.Keys[i]);
                    SerializeValue(writer, node.Values[i]);
                }

                if (!node.IsLeaf)
                {
                    foreach (var childId in node.Children)
                    {
                        writer.Write(childId);
                    }
                }

                node.IsModified = false;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error saving node {node.Id}: {ex.Message}");
            }
        }

        private void RemoveNodeFromStorage(long id)
        {
            try
            {
                var filePath = Path.Combine(_storagePath, $"{id}.node");
                if (File.Exists(filePath))
                    File.Delete(filePath);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error removing node {id}: {ex.Message}");
            }

            _nodeCache.Remove(id);
        }

        private void ManageCache()
        {
            if (_nodeCache.Count <= _cacheCapacity)
                return;

            var toRemove = _nodeCache.Where(kvp => kvp.Key != _root.Id)
                                   .OrderBy(kvp => kvp.Value.IsModified ? 1 : 0)
                                   .Take(_nodeCache.Count - _cacheCapacity / 2)
                                   .ToList();

            foreach (var item in toRemove)
            {
                if (item.Value.IsModified)
                {
                    SaveNode(item.Value);
                }
                _nodeCache.Remove(item.Key);
            }
        }

        private void SerializeKey(BinaryWriter writer, TKey key)
        {
            if (typeof(TKey) == typeof(int))
            {
                writer.Write((int)(object)key);
            }
            else if (typeof(TKey) == typeof(long))
            {
                writer.Write((long)(object)key);
            }
            else if (typeof(TKey) == typeof(string))
            {
                var str = (string)(object)key;
                writer.Write(str ?? "");
            }
            else
            {
                throw new NotSupportedException($"Key type {typeof(TKey)} not supported");
            }
        }

        private void SerializeValue(BinaryWriter writer, TValue value)
        {
            if (typeof(TValue) == typeof(int))
            {
                writer.Write((int)(object)value);
            }
            else if (typeof(TValue) == typeof(long))
            {
                writer.Write((long)(object)value);
            }
            else if (typeof(TValue) == typeof(string))
            {
                var str = (string)(object)value;
                writer.Write(str ?? "");
            }
            else if (typeof(TValue) == typeof(double))
            {
                writer.Write((double)(object)value);
            }
            else
            {
                throw new NotSupportedException($"Value type {typeof(TValue)} not supported");
            }
        }

        private TKey DeserializeKey(BinaryReader reader)
        {
            if (typeof(TKey) == typeof(int))
            {
                return (TKey)(object)reader.ReadInt32();
            }
            else if (typeof(TKey) == typeof(long))
            {
                return (TKey)(object)reader.ReadInt64();
            }
            else if (typeof(TKey) == typeof(string))
            {
                return (TKey)(object)reader.ReadString();
            }
            else
            {
                throw new NotSupportedException($"Key type {typeof(TKey)} not supported");
            }
        }

        private TValue DeserializeValue(BinaryReader reader)
        {
            if (typeof(TValue) == typeof(int))
            {
                return (TValue)(object)reader.ReadInt32();
            }
            else if (typeof(TValue) == typeof(long))
            {
                return (TValue)(object)reader.ReadInt64();
            }
            else if (typeof(TValue) == typeof(string))
            {
                return (TValue)(object)reader.ReadString();
            }
            else if (typeof(TValue) == typeof(double))
            {
                return (TValue)(object)reader.ReadDouble();
            }
            else
            {
                throw new NotSupportedException($"Value type {typeof(TValue)} not supported");
            }
        }

        private void SaveMetadata()
        {
            try
            {
                var metaPath = Path.Combine(_storagePath, "metadata.btree");
                using var stream = new FileStream(metaPath, FileMode.Create);
                using var writer = new BinaryWriter(stream);

                writer.Write(_minDegree);
                writer.Write(_nextNodeId);
                writer.Write(_root.Id);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error saving metadata: {ex.Message}");
            }
        }

        private void LoadMetadata()
        {
            var metaPath = Path.Combine(_storagePath, "metadata.btree");
            if (!File.Exists(metaPath))
                return;

            try
            {
                using var stream = new FileStream(metaPath, FileMode.Open);
                using var reader = new BinaryReader(stream);

                _nextNodeId = reader.ReadInt64();
                var rootId = reader.ReadInt64();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading metadata: {ex.Message}");
                _nextNodeId = 1;
            }
        }

        private void CollectStats(BTreeNode node, int depth, BTreeStats stats)
        {
            stats.TotalNodes++;
            stats.TotalKeys += node.KeyCount;

            if (depth > stats.MaxDepth)
                stats.MaxDepth = depth;

            if (node.IsLeaf)
            {
                stats.LeafNodes++;
                if (depth < stats.MinDepth || stats.MinDepth == -1)
                    stats.MinDepth = depth;
            }

            if (!node.IsLeaf)
            {
                foreach (var childId in node.Children)
                {
                    var child = LoadNode(childId);
                    CollectStats(child, depth + 1, stats);
                }
            }
        }

        private List<BTreeNode> GetAllNodes()
        {
            var nodes = new List<BTreeNode>();
            CollectNodes(_root, nodes);
            return nodes;
        }

        private void CollectNodes(BTreeNode node, List<BTreeNode> nodes)
        {
            nodes.Add(node);
            if (!node.IsLeaf)
            {
                foreach (var childId in node.Children)
                {
                    var child = LoadNode(childId);
                    CollectNodes(child, nodes);
                }
            }
        }
    }

    public class BTreeStats
    {
        public int TotalNodes { get; set; }
        public int LeafNodes { get; set; }
        public long TotalKeys { get; set; }
        public int MaxDepth { get; set; }
        public int MinDepth { get; set; } = -1;
        public double AverageKeysPerNode => TotalNodes > 0 ? (double)TotalKeys / TotalNodes : 0;
        public double FillFactor => TotalNodes > 0 ? AverageKeysPerNode / (2 * (Math.Sqrt(TotalNodes) - 1)) : 0;

        public void PrintStats()
        {
            Console.WriteLine("=== B-TREE STATISTICS ===");
            Console.WriteLine($"Total Nodes: {TotalNodes}");
            Console.WriteLine($"Leaf Nodes: {LeafNodes}");
            Console.WriteLine($"Total Keys: {TotalKeys}");
            Console.WriteLine($"Max Depth: {MaxDepth}");
            Console.WriteLine($"Min Depth: {MinDepth}");
            Console.WriteLine($"Avg Keys/Node: {AverageKeysPerNode:F2}");
            Console.WriteLine($"Fill Factor: {FillFactor:P2}");
        }
    }

    public class BTreePerformanceTester
    {
        public static void TestPerformance(int dataSize = 10000)
        {
            Console.WriteLine($"=== B-TREE PERFORMANCE TEST ({dataSize} elements) ===");

            var btree = new BTree<int, string>(minDegree: 10, cacheCapacity: 1000);
            var random = new Random();

            Console.WriteLine("\n--- Insertion Test ---");
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            for (int i = 0; i < dataSize; i++)
            {
                btree.Insert(i, $"value_{i}");
            }

            var insertTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Insertion time: {insertTime} ms");
            Console.WriteLine($"Operations per second: {dataSize * 1000L / insertTime}");

            Console.WriteLine("\n--- Search Test ---");
            stopwatch.Restart();

            for (int i = 0; i < 1000; i++)
            {
                var key = random.Next(dataSize);
                try
                {
                    var value = btree.Search(key);
                }
                catch (KeyNotFoundException)
                {
                }
            }

            var searchTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Search time: {searchTime} ms");

            Console.WriteLine("\n--- Range Search Test ---");
            stopwatch.Restart();

            var results = btree.RangeSearch(dataSize / 4, dataSize / 2);
            var rangeTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Range search time: {rangeTime} ms");
            Console.WriteLine($"Found {results.Count} elements");

            var stats = btree.GetStats();
            stats.PrintStats();

            Console.WriteLine("\n--- Disk Operations ---");
            stopwatch.Restart();
            btree.FlushToDisk();
            var flushTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Flush to disk: {flushTime} ms");

            long memory = GC.GetTotalMemory(true);
            Console.WriteLine($"Memory usage: {memory / 1024 / 1024} MB");
        }
    }

    public class PriorityQueueNode<T> : IComparable<PriorityQueueNode<T>>
    {
        public T Value { get; set; }
        public double Priority { get; set; }
        public int Index { get; set; }
        public bool IsMarked { get; set; }
        public PriorityQueueNode<T> Parent { get; set; }
        public LinkedList<PriorityQueueNode<T>> Children { get; set; }
        public int Degree => Children.Count;

        public PriorityQueueNode(T value, double priority)
        {
            Value = value;
            Priority = priority;
            Children = new LinkedList<PriorityQueueNode<T>>();
            Index = -1;
        }

        public int CompareTo(PriorityQueueNode<T> other)
        {
            return Priority.CompareTo(other.Priority);
        }

        public override string ToString()
        {
            return $"{Value}({Priority})";
        }
    }

    public class PriorityQueueWithDecreaseKey<T>
    {
        private readonly LinkedList<PriorityQueueNode<T>> _roots;
        private readonly Dictionary<T, PriorityQueueNode<T>> _nodeMap;
        private PriorityQueueNode<T> _minNode;
        private int _count;
        private int _markedCount;

        public int Count => _count;
        public bool IsEmpty => _count == 0;
        public T Min => _minNode != null ? _minNode.Value : throw new InvalidOperationException("Queue is empty");

        public PriorityQueueWithDecreaseKey()
        {
            _roots = new LinkedList<PriorityQueueNode<T>>();
            _nodeMap = new Dictionary<T, PriorityQueueNode<T>>();
            _minNode = null;
            _count = 0;
            _markedCount = 0;
        }

        public void Insert(T value, double priority)
        {
            if (_nodeMap.ContainsKey(value))
                throw new ArgumentException($"Element {value} already exists in the queue");

            var node = new PriorityQueueNode<T>(value, priority);
            _nodeMap[value] = node;

            AddToRoots(node);

            _count++;
            UpdateMinNode(node);
        }

        public T ExtractMin()
        {
            if (IsEmpty)
                throw new InvalidOperationException("Queue is empty");

            var minNode = _minNode;

            foreach (var child in minNode.Children)
            {
                child.Parent = null;
                child.IsMarked = false;
                AddToRoots(child);
            }

            _roots.Remove(minNode);
            _nodeMap.Remove(minNode.Value);
            _count--;

            if (_count == 0)
            {
                _minNode = null;
            }
            else
            {
                Consolidate();
                UpdateMinNode();
            }

            return minNode.Value;
        }

        public void DecreaseKey(T value, double newPriority)
        {
            if (!_nodeMap.TryGetValue(value, out var node))
                throw new ArgumentException($"Element {value} not found in queue");

            if (newPriority > node.Priority)
                throw new ArgumentException("New priority must be less than current priority");

            node.Priority = newPriority;
            var parent = node.Parent;

            if (parent != null && node.Priority < parent.Priority)
            {
                Cut(node, parent);
                CascadingCut(parent);
            }

            UpdateMinNode(node);
        }

        public bool Remove(T value)
        {
            if (!_nodeMap.ContainsKey(value))
                return false;

            DecreaseKey(value, double.NegativeInfinity);
            ExtractMin();
            return true;
        }

        public bool Contains(T value)
        {
            return _nodeMap.ContainsKey(value);
        }

        public double GetPriority(T value)
        {
            if (!_nodeMap.TryGetValue(value, out var node))
                throw new ArgumentException($"Element {value} not found in queue");

            return node.Priority;
        }

        public void Merge(PriorityQueueWithDecreaseKey<T> other)
        {
            foreach (var root in other._roots)
            {
                AddToRoots(root);
                _nodeMap[root.Value] = root;
            }

            _count += other._count;
            UpdateMinNode(other._minNode);

            other._roots.Clear();
            other._nodeMap.Clear();
            other._count = 0;
            other._minNode = null;
        }

        public void Clear()
        {
            _roots.Clear();
            _nodeMap.Clear();
            _minNode = null;
            _count = 0;
            _markedCount = 0;
        }

        private void AddToRoots(PriorityQueueNode<T> node)
        {
            node.Parent = null;
            node.IsMarked = false;
            _roots.AddLast(node);
        }

        private void UpdateMinNode(PriorityQueueNode<T> candidate = null)
        {
            if (_minNode == null || candidate != null && candidate.Priority < _minNode.Priority)
            {
                _minNode = candidate;
            }

            if (_minNode == null || candidate == null)
            {
                _minNode = _roots.First?.Value;
                foreach (var root in _roots)
                {
                    if (root.Priority < _minNode.Priority)
                    {
                        _minNode = root;
                    }
                }
            }
        }

        private void Consolidate()
        {
            if (_roots.Count <= 1) return;

            var degreeTable = new Dictionary<int, PriorityQueueNode<T>>();
            var rootsToProcess = _roots.ToList();
            _roots.Clear();

            foreach (var root in rootsToProcess)
            {
                var current = root;
                while (degreeTable.ContainsKey(current.Degree))
                {
                    var other = degreeTable[current.Degree];
                    degreeTable.Remove(current.Degree);

                    if (current.Priority > other.Priority)
                    {
                        (current, other) = (other, current);
                    }

                    Link(current, other);
                }
                degreeTable[current.Degree] = current;
            }

            foreach (var tree in degreeTable.Values)
            {
                AddToRoots(tree);
            }
        }

        private void Link(PriorityQueueNode<T> parent, PriorityQueueNode<T> child)
        {
            _roots.Remove(child);
            child.Parent = parent;
            parent.Children.AddLast(child);
            child.IsMarked = false;
        }

        private void Cut(PriorityQueueNode<T> child, PriorityQueueNode<T> parent)
        {
            parent.Children.Remove(child);
            child.Parent = null;
            child.IsMarked = false;
            AddToRoots(child);
        }

        private void CascadingCut(PriorityQueueNode<T> node)
        {
            var parent = node.Parent;
            if (parent != null)
            {
                if (!node.IsMarked)
                {
                    node.IsMarked = true;
                    _markedCount++;
                }
                else
                {
                    Cut(node, parent);
                    CascadingCut(parent);
                }
            }
        }

        public void PrintStructure()
        {
            Console.WriteLine($"Priority Queue (Count: {_count}, Min: {_minNode})");
            Console.WriteLine("Roots: " + string.Join(", ", _roots));

            int treeIndex = 0;
            foreach (var root in _roots)
            {
                Console.WriteLine($"Tree {treeIndex++}:");
                PrintTree(root, 1);
            }
        }

        private void PrintTree(PriorityQueueNode<T> node, int depth)
        {
            var indent = new string(' ', depth * 2);
            Console.WriteLine($"{indent}{node} {(node.IsMarked ? "[Marked]" : "")}");

            foreach (var child in node.Children)
            {
                PrintTree(child, depth + 1);
            }
        }

        public bool ValidateStructure()
        {
            if (_minNode != null && !_roots.Contains(_minNode))
                return false;

            foreach (var root in _roots)
            {
                if (root.Parent != null)
                    return false;

                if (!ValidateTree(root))
                    return false;
            }

            return _nodeMap.Count == _count;
        }

        private bool ValidateTree(PriorityQueueNode<T> node)
        {
            if (node.Parent != null && node.Priority < node.Parent.Priority)
                return false;

            foreach (var child in node.Children)
            {
                if (child.Parent != node)
                    return false;

                if (!ValidateTree(child))
                    return false;
            }

            return true;
        }
    }

    public class DijkstraWithPriorityQueue
    {
        public static (double[] distances, int[] previous) FindShortestPath(
            Dictionary<int, List<(int to, double weight)>> graph,
            int source)
        {
            int n = graph.Count;
            var distances = new double[n];
            var previous = new int[n];
            var visited = new bool[n];

            for (int i = 0; i < n; i++)
            {
                distances[i] = double.PositiveInfinity;
                previous[i] = -1;
            }
            distances[source] = 0;

            var pq = new PriorityQueueWithDecreaseKey<int>();
            pq.Insert(source, 0);

            while (!pq.IsEmpty)
            {
                var current = pq.ExtractMin();
                visited[current] = true;

                if (!graph.ContainsKey(current))
                    continue;

                foreach (var (neighbor, weight) in graph[current])
                {
                    if (visited[neighbor])
                        continue;

                    double newDist = distances[current] + weight;
                    if (newDist < distances[neighbor])
                    {
                        distances[neighbor] = newDist;
                        previous[neighbor] = current;

                        if (pq.Contains(neighbor))
                        {
                            pq.DecreaseKey(neighbor, newDist);
                        }
                        else
                        {
                            pq.Insert(neighbor, newDist);
                        }
                    }
                }
            }

            return (distances, previous);
        }

        public static List<int> ReconstructPath(int[] previous, int target)
        {
            var path = new List<int>();
            for (int at = target; at != -1; at = previous[at])
            {
                path.Add(at);
            }
            path.Reverse();
            return path;
        }
    }

    public class PriorityQueuePerformanceTester
    {
        public static void TestBasicOperations()
        {
            Console.WriteLine("=== ТЕСТ БАЗОВЫХ ОПЕРАЦИЙ ===");

            var pq = new PriorityQueueWithDecreaseKey<int>();

            pq.Insert(1, 10);
            pq.Insert(2, 5);
            pq.Insert(3, 15);
            pq.Insert(4, 3);

            Console.WriteLine("После вставки 4 элементов:");
            pq.PrintStructure();
            Console.WriteLine($"Min: {pq.Min}");

            var min1 = pq.ExtractMin();
            Console.WriteLine($"\nИзвлечен минимум: {min1}");
            Console.WriteLine($"Новый Min: {pq.Min}");

            pq.DecreaseKey(3, 2);
            Console.WriteLine($"\nПосле уменьшения приоритета элемента 3 до 2:");
            pq.PrintStructure();
            Console.WriteLine($"Min: {pq.Min}");

            pq.Remove(1);
            Console.WriteLine($"\nПосле удаления элемента 1:");
            pq.PrintStructure();

            Console.WriteLine($"\nСтруктура валидна: {pq.ValidateStructure()}");
        }

        public static void TestPerformance(int operationCount = 100000)
        {
            Console.WriteLine($"\n=== ТЕСТ ПРОИЗВОДИТЕЛЬНОСТИ ({operationCount} операций) ===");

            var pq = new PriorityQueueWithDecreaseKey<int>();
            var random = new Random();

            // Тест вставки
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            for (int i = 0; i < operationCount; i++)
            {
                pq.Insert(i, random.NextDouble() * 1000);
            }
            var insertTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Вставка {operationCount} элементов: {insertTime} мс");

            stopwatch.Restart();
            int decreaseCount = 0;
            for (int i = 0; i < operationCount / 10; i++)
            {
                if (pq.Contains(i))
                {
                    double currentPriority = pq.GetPriority(i);
                    double newPriority = currentPriority - random.NextDouble() * 10 - 1;
                    if (newPriority < 0) newPriority = 0;

                    pq.DecreaseKey(i, newPriority);
                    decreaseCount++;
                }
            }
            var decreaseTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Уменьшение приоритета {decreaseCount} элементов: {decreaseTime} мс");

            // Тест извлечения минимума
            stopwatch.Restart();
            int extractCount = 0;
            while (!pq.IsEmpty && extractCount < operationCount / 2)
            {
                pq.ExtractMin();
                extractCount++;
            }
            var extractTime = stopwatch.ElapsedMilliseconds;
            Console.WriteLine($"Извлечение {extractCount} минимумов: {extractTime} мс");

            Console.WriteLine($"Оставшиеся элементы: {pq.Count}");
            Console.WriteLine($"Операций в секунду: {operationCount * 1000L / (insertTime + decreaseTime + extractTime)}");
        }

        public static void TestDijkstraPerformance()
        {
            Console.WriteLine("\n=== ТЕСТ АЛГОРИТМА ДЕЙКСТРЫ ===");

            var graph = GenerateRandomGraph(1000, 5000);
            int source = 0;

            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var (distances, previous) = DijkstraWithPriorityQueue.FindShortestPath(graph, source);
            var ourTime = stopwatch.ElapsedMilliseconds;

            stopwatch.Restart();
            var (distances2, previous2) = DijkstraWithSortedSet(graph, source);
            var sortedSetTime = stopwatch.ElapsedMilliseconds;

            Console.WriteLine($"Наша очередь: {ourTime} мс");
            Console.WriteLine($"SortedSet: {sortedSetTime} мс");
            Console.WriteLine($"Ускорение: {(double)sortedSetTime / ourTime:F2}x");

            bool correct = true;
            for (int i = 0; i < distances.Length; i++)
            {
                if (Math.Abs(distances[i] - distances2[i]) > 1e-9)
                {
                    correct = false;
                    break;
                }
            }
            Console.WriteLine($"Результаты корректны: {correct}");
        }

        private static Dictionary<int, List<(int to, double weight)>> GenerateRandomGraph(
            int vertices, int edges)
        {
            var graph = new Dictionary<int, List<(int, double)>>();
            var random = new Random();

            for (int i = 0; i < vertices; i++)
            {
                graph[i] = new List<(int, double)>();
            }

            for (int i = 0; i < edges; i++)
            {
                int from = random.Next(vertices);
                int to = random.Next(vertices);
                double weight = random.NextDouble() * 100;

                if (from != to)
                {
                    graph[from].Add((to, weight));
                }
            }

            return graph;
        }

        private static (double[] distances, int[] previous) DijkstraWithSortedSet(
            Dictionary<int, List<(int to, double weight)>> graph, int source)
        {
            int n = graph.Count;
            var distances = new double[n];
            var previous = new int[n];
            var visited = new bool[n];

            for (int i = 0; i < n; i++)
            {
                distances[i] = double.PositiveInfinity;
                previous[i] = -1;
            }
            distances[source] = 0;

            var set = new SortedSet<(double dist, int node)>();
            set.Add((0, source));

            while (set.Count > 0)
            {
                var current = set.Min.node;
                set.Remove(set.Min);
                visited[current] = true;

                if (!graph.ContainsKey(current))
                    continue;

                foreach (var (neighbor, weight) in graph[current])
                {
                    if (visited[neighbor])
                        continue;

                    double newDist = distances[current] + weight;
                    if (newDist < distances[neighbor])
                    {
                        set.Remove((distances[neighbor], neighbor));

                        distances[neighbor] = newDist;
                        previous[neighbor] = current;
                        set.Add((newDist, neighbor));
                    }
                }
            }

            return (distances, previous);
        }

        public static void TestStress(int size = 100000)
        {
            Console.WriteLine($"\n=== СТРЕСС-ТЕСТ ({size} элементов) ===");

            var pq = new PriorityQueueWithDecreaseKey<int>();
            var random = new Random();

            Console.WriteLine("Массовая вставка...");
            for (int i = 0; i < size; i++)
            {
                pq.Insert(i, random.NextDouble() * size);
            }

            Console.WriteLine("Операции уменьшения приоритета...");
            for (int i = 0; i < size / 10; i++)
            {
                int element = random.Next(size);
                if (pq.Contains(element))
                {
                    double currentPriority = pq.GetPriority(element);
                    double newPriority = random.NextDouble() * 100;

                    if (newPriority < currentPriority)
                    {
                        pq.DecreaseKey(element, newPriority);
                    }
                }
            }

            Console.WriteLine("Извлечение всех элементов...");
            int count = 0;
            double lastPriority = -1;
            while (!pq.IsEmpty)
            {
                var priority = pq.GetPriority(pq.Min);
                if (priority < lastPriority)
                {
                    Console.WriteLine("ОШИБКА: Нарушен порядок!");
                    break;
                }
                lastPriority = priority;
                pq.ExtractMin();
                count++;

                if (count % 10000 == 0)
                {
                    Console.WriteLine($"  Извлечено {count} элементов");
                }
            }

            Console.WriteLine($"Успешно извлечено {count} элементов");
            Console.WriteLine($"Структура валидна: {pq.ValidateStructure()}");
        }

        public class BinaryHeapWithDecreaseKey<T>
        {
            private readonly List<PriorityQueueNode<T>> _heap;
            private readonly Dictionary<T, int> _positionMap;
            private readonly IComparer<double> _comparer;

            public int Count => _heap.Count;
            public bool IsEmpty => _heap.Count == 0;

            public BinaryHeapWithDecreaseKey()
            {
                _heap = new List<PriorityQueueNode<T>>();
                _positionMap = new Dictionary<T, int>();
                _comparer = Comparer<double>.Default;
            }

            public void Insert(T value, double priority)
            {
                if (_positionMap.ContainsKey(value))
                    throw new ArgumentException("Element already exists");

                var node = new PriorityQueueNode<T>(value, priority);
                _heap.Add(node);
                int index = _heap.Count - 1;
                _positionMap[value] = index;
                node.Index = index;

                BubbleUp(index);
            }

            public T ExtractMin()
            {
                if (IsEmpty)
                    throw new InvalidOperationException("Heap is empty");

                var min = _heap[0];
                _positionMap.Remove(min.Value);

                if (_heap.Count > 1)
                {
                    _heap[0] = _heap[^1];
                    _positionMap[_heap[0].Value] = 0;
                    _heap[0].Index = 0;
                }

                _heap.RemoveAt(_heap.Count - 1);

                if (!IsEmpty)
                {
                    BubbleDown(0);
                }

                return min.Value;
            }

            public void DecreaseKey(T value, double newPriority)
            {
                if (!_positionMap.TryGetValue(value, out int index))
                    throw new ArgumentException("Element not found");

                var node = _heap[index];
                if (newPriority > node.Priority)
                    throw new ArgumentException("New priority must be smaller");

                node.Priority = newPriority;
                BubbleUp(index);
            }

            private void BubbleUp(int index)
            {
                while (index > 0)
                {
                    int parent = (index - 1) / 2;
                    if (_comparer.Compare(_heap[index].Priority, _heap[parent].Priority) >= 0)
                        break;

                    Swap(index, parent);
                    index = parent;
                }
            }

            private void BubbleDown(int index)
            {
                while (true)
                {
                    int left = 2 * index + 1;
                    int right = 2 * index + 2;
                    int smallest = index;

                    if (left < _heap.Count && _comparer.Compare(_heap[left].Priority, _heap[smallest].Priority) < 0)
                        smallest = left;

                    if (right < _heap.Count && _comparer.Compare(_heap[right].Priority, _heap[smallest].Priority) < 0)
                        smallest = right;

                    if (smallest == index)
                        break;

                    Swap(index, smallest);
                    index = smallest;
                }
            }

            private void Swap(int i, int j)
            {
                (_heap[i], _heap[j]) = (_heap[j], _heap[i]);
                _heap[i].Index = i;
                _heap[j].Index = j;
                _positionMap[_heap[i].Value] = i;
                _positionMap[_heap[j].Value] = j;
            }
        }

        // 1.8: Алгоритм Форда-Фалкерсона для максимального потока
        public class MaxFlowFinder
        {
            private int[,] capacity;
            private int[,] flow;
            private int[] parent;
            private bool[] visited;
            private int n;

            public MaxFlowFinder(int vertices)
            {
                n = vertices;
                capacity = new int[n, n];
                flow = new int[n, n];
                parent = new int[n];
                visited = new bool[n];
            }

            public void AddEdge(int from, int to, int cap)
            {
                capacity[from, to] += cap;
            }

            private bool BFS(int source, int sink)
            {
                Array.Fill(visited, false);
                Array.Fill(parent, -1);

                Queue<int> queue = new Queue<int>();
                queue.Enqueue(source);
                visited[source] = true;

                while (queue.Count > 0)
                {
                    int u = queue.Dequeue();

                    for (int v = 0; v < n; v++)
                    {
                        if (!visited[v] && capacity[u, v] - flow[u, v] > 0)
                        {
                            visited[v] = true;
                            parent[v] = u;
                            queue.Enqueue(v);

                            if (v == sink)
                                return true;
                        }
                    }
                }

                return false;
            }

            public int FindMaxFlow(int source, int sink)
            {
                int maxFlow = 0;

                while (BFS(source, sink))
                {
                    int pathFlow = int.MaxValue;

                    for (int v = sink; v != source; v = parent[v])
                    {
                        int u = parent[v];
                        pathFlow = Math.Min(pathFlow, capacity[u, v] - flow[u, v]);
                    }

                    for (int v = sink; v != source; v = parent[v])
                    {
                        int u = parent[v];
                        flow[u, v] += pathFlow;
                        flow[v, u] -= pathFlow;
                    }

                    maxFlow += pathFlow;
                }

                return maxFlow;
            }

            public List<(int from, int to, int flow)> GetFlowEdges()
            {
                var edges = new List<(int, int, int)>();

                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < n; j++)
                    {
                        if (flow[i, j] > 0)
                        {
                            edges.Add((i, j, flow[i, j]));
                        }
                    }
                }

                return edges;
            }

            public List<int> FindMinCut(int source)
            {
                var minCut = new List<int>();

                for (int i = 0; i < n; i++)
                {
                    if (visited[i])
                    {
                        minCut.Add(i);
                    }
                }

                return minCut;
            }

            public void PrintFlowNetwork()
            {
                Console.WriteLine("Flow Network:");
                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < n; j++)
                    {
                        if (capacity[i, j] > 0)
                        {
                            Console.WriteLine($"Edge {i} -> {j}: Capacity = {capacity[i, j]}, Flow = {flow[i, j]}");
                        }
                    }
                }
            }
        }

        // 1.9: Поиск мостов в графе
        public class BridgeFinder
        {
            private List<int>[] graph;
            private int[] disc;
            private int[] low;
            private int[] parent;
            private bool[] visited;
            private int time;
            private List<(int, int)> bridges;

            public BridgeFinder(int vertices)
            {
                graph = new List<int>[vertices];
                for (int i = 0; i < vertices; i++)
                    graph[i] = new List<int>();

                disc = new int[vertices];
                low = new int[vertices];
                parent = new int[vertices];
                visited = new bool[vertices];
                bridges = new List<(int, int)>();
            }

            public void AddEdge(int u, int v)
            {
                graph[u].Add(v);
                graph[v].Add(u);
            }

            public List<(int, int)> FindBridges()
            {
                bridges.Clear();
                Array.Fill(disc, -1);
                Array.Fill(low, -1);
                Array.Fill(parent, -1);
                Array.Fill(visited, false);
                time = 0;

                for (int i = 0; i < graph.Length; i++)
                {
                    if (!visited[i])
                    {
                        DFS(i);
                    }
                }

                return bridges;
            }

            private void DFS(int u)
            {
                visited[u] = true;
                disc[u] = low[u] = ++time;

                foreach (int v in graph[u])
                {
                    if (!visited[v])
                    {
                        parent[v] = u;
                        DFS(v);

                        low[u] = Math.Min(low[u], low[v]);

                        if (low[v] > disc[u])
                        {
                            bridges.Add((u, v));
                        }
                    }
                    else if (v != parent[u])
                    {
                        low[u] = Math.Min(low[u], disc[v]);
                    }
                }
            }

            public List<List<int>> FindTwoEdgeConnectedComponents()
            {
                var components = new List<List<int>>();
                var compId = new int[graph.Length];
                Array.Fill(compId, -1);
                int currentComp = 0;

                for (int i = 0; i < graph.Length; i++)
                {
                    if (compId[i] == -1)
                    {
                        var component = new List<int>();
                        DFSComponents(i, compId, currentComp, component);
                        components.Add(component);
                        currentComp++;
                    }
                }

                return components;
            }

            private void DFSComponents(int u, int[] compId, int comp, List<int> component)
            {
                compId[u] = comp;
                component.Add(u);

                foreach (int v in graph[u])
                {
                    if (compId[v] == -1 && !bridges.Contains((u, v)) && !bridges.Contains((v, u)))
                    {
                        DFSComponents(v, compId, comp, component);
                    }
                }
            }
        }

        // 1.10: Поиск точек сочленения
        public class ArticulationPointsFinder
        {
            private List<int>[] graph;
            private int[] disc;
            private int[] low;
            private int[] parent;
            private bool[] visited;
            private bool[] ap;
            private int time;

            public ArticulationPointsFinder(int vertices)
            {
                graph = new List<int>[vertices];
                for (int i = 0; i < vertices; i++)
                    graph[i] = new List<int>();

                disc = new int[vertices];
                low = new int[vertices];
                parent = new int[vertices];
                visited = new bool[vertices];
                ap = new bool[vertices];
            }

            public void AddEdge(int u, int v)
            {
                graph[u].Add(v);
                graph[v].Add(u);
            }

            public List<int> FindArticulationPoints()
            {
                Array.Fill(disc, -1);
                Array.Fill(low, -1);
                Array.Fill(parent, -1);
                Array.Fill(visited, false);
                Array.Fill(ap, false);
                time = 0;

                for (int i = 0; i < graph.Length; i++)
                {
                    if (!visited[i])
                    {
                        DFS(i);
                    }
                }

                var points = new List<int>();
                for (int i = 0; i < ap.Length; i++)
                {
                    if (ap[i])
                        points.Add(i);
                }

                return points;
            }

            private void DFS(int u)
            {
                visited[u] = true;
                disc[u] = low[u] = ++time;
                int children = 0;

                foreach (int v in graph[u])
                {
                    if (!visited[v])
                    {
                        children++;
                        parent[v] = u;
                        DFS(v);

                        low[u] = Math.Min(low[u], low[v]);

                        if (parent[u] == -1 && children > 1)
                            ap[u] = true;

                        if (parent[u] != -1 && low[v] >= disc[u])
                            ap[u] = true;
                    }
                    else if (v != parent[u])
                    {
                        low[u] = Math.Min(low[u], disc[v]);
                    }
                }
            }

            public List<List<int>> FindBiconnectedComponents()
            {
                var components = new List<List<int>>();
                var stack = new Stack<(int, int)>();
                var compId = new int[graph.Length];
                Array.Fill(compId, -1);

                for (int i = 0; i < graph.Length; i++)
                {
                    if (compId[i] == -1)
                    {
                        DFSBiconnected(i, -1, compId, components, stack);
                    }
                }

                return components;
            }

            private void DFSBiconnected(int u, int parent, int[] compId, List<List<int>> components, Stack<(int, int)> stack)
            {
                disc[u] = low[u] = ++time;
                int children = 0;

                foreach (int v in graph[u])
                {
                    if (v == parent) continue;

                    if (disc[v] == -1)
                    {
                        children++;
                        stack.Push((u, v));
                        DFSBiconnected(v, u, compId, components, stack);

                        low[u] = Math.Min(low[u], low[v]);

                        if ((parent == -1 && children > 1) || (parent != -1 && low[v] >= disc[u]))
                        {
                            var component = new List<int>();
                            while (stack.Peek() != (u, v))
                            {
                                var edge = stack.Pop();
                                if (compId[edge.Item1] == -1)
                                {
                                    compId[edge.Item1] = components.Count;
                                    component.Add(edge.Item1);
                                }
                                if (compId[edge.Item2] == -1)
                                {
                                    compId[edge.Item2] = components.Count;
                                    component.Add(edge.Item2);
                                }
                            }
                            var lastEdge = stack.Pop();
                            if (compId[lastEdge.Item1] == -1)
                            {
                                compId[lastEdge.Item1] = components.Count;
                                component.Add(lastEdge.Item1);
                            }
                            if (compId[lastEdge.Item2] == -1)
                            {
                                compId[lastEdge.Item2] = components.Count;
                                component.Add(lastEdge.Item2);
                            }
                            components.Add(component);
                        }
                    }
                    else if (disc[v] < disc[u])
                    {
                        stack.Push((u, v));
                        low[u] = Math.Min(low[u], disc[v]);
                    }
                }
            }
        }

        // 1.11: Наименьший общий предок (LCA)
        public class LCAFinder
        {
            private List<int>[] tree;
            private int[,] ancestors;
            private int[] depth;
            private int[] tin, tout;
            private int timer;
            private int logn;

            public LCAFinder(int vertices)
            {
                tree = new List<int>[vertices];
                for (int i = 0; i < vertices; i++)
                    tree[i] = new List<int>();

                depth = new int[vertices];
                tin = new int[vertices];
                tout = new int[vertices];
                logn = (int)Math.Ceiling(Math.Log(vertices, 2)) + 1;
                ancestors = new int[vertices, logn];
            }

            public void AddEdge(int u, int v)
            {
                tree[u].Add(v);
                tree[v].Add(u);
            }

            public void Preprocess(int root)
            {
                timer = 0;
                DFS(root, root);
            }

            private void DFS(int u, int parent)
            {
                tin[u] = ++timer;
                ancestors[u, 0] = parent;

                for (int i = 1; i < logn; i++)
                {
                    ancestors[u, i] = ancestors[ancestors[u, i - 1], i - 1];
                }

                foreach (int v in tree[u])
                {
                    if (v != parent)
                    {
                        depth[v] = depth[u] + 1;
                        DFS(v, u);
                    }
                }

                tout[u] = ++timer;
            }

            private bool IsAncestor(int u, int v)
            {
                return tin[u] <= tin[v] && tout[u] >= tout[v];
            }

            public int FindLCA(int u, int v)
            {
                if (IsAncestor(u, v)) return u;
                if (IsAncestor(v, u)) return v;

                for (int i = logn - 1; i >= 0; i--)
                {
                    if (!IsAncestor(ancestors[u, i], v))
                    {
                        u = ancestors[u, i];
                    }
                }

                return ancestors[u, 0];
            }

            public int FindDistance(int u, int v)
            {
                int lca = FindLCA(u, v);
                return depth[u] + depth[v] - 2 * depth[lca];
            }

            // Наивный метод для сравнения
            public int FindLCANaive(int u, int v)
            {
                while (u != v)
                {
                    if (depth[u] > depth[v])
                        u = ancestors[u, 0];
                    else
                        v = ancestors[v, 0];
                }
                return u;
            }
        }

        // 1.12: Алгоритм Крускала для MST
        public class KruskalMST
        {
            public class Edge : IComparable<Edge>
            {
                public int From { get; set; }
                public int To { get; set; }
                public int Weight { get; set; }

                public Edge(int from, int to, int weight)
                {
                    From = from;
                    To = to;
                    Weight = weight;
                }

                public int CompareTo(Edge other)
                {
                    return Weight.CompareTo(other.Weight);
                }
            }

            private List<Edge> edges;
            private int vertices;

            public KruskalMST(int vertices)
            {
                this.vertices = vertices;
                edges = new List<Edge>();
            }

            public void AddEdge(int from, int to, int weight)
            {
                edges.Add(new Edge(from, to, weight));
            }

            public (List<Edge> mst, int totalWeight) FindMST()
            {
                edges.Sort();
                var uf = new UnionFind(vertices);
                var mst = new List<Edge>();
                int totalWeight = 0;

                foreach (var edge in edges)
                {
                    if (uf.Union(edge.From, edge.To))
                    {
                        mst.Add(edge);
                        totalWeight += edge.Weight;

                        if (mst.Count == vertices - 1)
                            break;
                    }
                }

                return (mst, totalWeight);
            }

            public List<List<Edge>> FindAllMSTs()
            {
                edges.Sort();
                var allMSTs = new List<List<Edge>>();
                FindAllMSTsRecursive(0, new List<Edge>(), new UnionFind(vertices), allMSTs);
                return allMSTs;
            }

            private void FindAllMSTsRecursive(int index, List<Edge> current, UnionFind uf, List<List<Edge>> allMSTs)
            {
                if (current.Count == vertices - 1)
                {
                    allMSTs.Add(new List<Edge>(current));
                    return;
                }

                if (index >= edges.Count)
                    return;

                var edge = edges[index];

                if (!uf.Connected(edge.From, edge.To))
                {
                    // Создаем копию UnionFind для ветвления
                    var ufCopy = new UnionFind(vertices);
                    // Копируем состояние из текущего UnionFind
                    for (int i = 0; i < vertices; i++)
                    {
                        for (int j = i + 1; j < vertices; j++)
                        {
                            if (uf.Connected(i, j))
                            {
                                ufCopy.Union(i, j);
                            }
                        }
                    }

                    ufCopy.Union(edge.From, edge.To);
                    current.Add(edge);
                    FindAllMSTsRecursive(index + 1, current, ufCopy, allMSTs);
                    current.RemoveAt(current.Count - 1);
                }

                FindAllMSTsRecursive(index + 1, current, uf, allMSTs);
            }
        }

        // 1.13: Сильно связные компоненты (Косарайю)
        public class SCCFinder
        {
            private List<int>[] graph;
            private List<int>[] reverseGraph;
            private bool[] visited;
            private Stack<int> stack;
            private List<List<int>> scc;

            public SCCFinder(int vertices)
            {
                graph = new List<int>[vertices];
                reverseGraph = new List<int>[vertices];
                for (int i = 0; i < vertices; i++)
                {
                    graph[i] = new List<int>();
                    reverseGraph[i] = new List<int>();
                }

                visited = new bool[vertices];
                stack = new Stack<int>();
                scc = new List<List<int>>();
            }

            public void AddEdge(int from, int to)
            {
                graph[from].Add(to);
                reverseGraph[to].Add(from);
            }

            public List<List<int>> FindSCC()
            {
                scc.Clear();
                Array.Fill(visited, false);

                for (int i = 0; i < graph.Length; i++)
                {
                    if (!visited[i])
                    {
                        DFS1(i);
                    }
                }

                Array.Fill(visited, false);

                while (stack.Count > 0)
                {
                    int v = stack.Pop();
                    if (!visited[v])
                    {
                        var component = new List<int>();
                        DFS2(v, component);
                        scc.Add(component);
                    }
                }

                return scc;
            }

            private void DFS1(int v)
            {
                visited[v] = true;
                foreach (int u in graph[v])
                {
                    if (!visited[u])
                    {
                        DFS1(u);
                    }
                }
                stack.Push(v);
            }

            private void DFS2(int v, List<int> component)
            {
                visited[v] = true;
                component.Add(v);
                foreach (int u in reverseGraph[v])
                {
                    if (!visited[u])
                    {
                        DFS2(u, component);
                    }
                }
            }

            public List<int>[] BuildCondensationGraph()
            {
                var sccList = FindSCC();
                var compId = new int[graph.Length];

                for (int i = 0; i < sccList.Count; i++)
                {
                    foreach (int v in sccList[i])
                    {
                        compId[v] = i;
                    }
                }

                var condensation = new List<int>[sccList.Count];
                for (int i = 0; i < sccList.Count; i++)
                    condensation[i] = new List<int>();

                var edges = new HashSet<(int, int)>();

                for (int u = 0; u < graph.Length; u++)
                {
                    foreach (int v in graph[u])
                    {
                        int compU = compId[u];
                        int compV = compId[v];
                        if (compU != compV && !edges.Contains((compU, compV)))
                        {
                            condensation[compU].Add(compV);
                            edges.Add((compU, compV));
                        }
                    }
                }

                return condensation;
            }

            public List<int> TopologicalSortSCC()
            {
                var condensation = BuildCondensationGraph();
                var visited = new bool[condensation.Length];
                var order = new List<int>();

                for (int i = 0; i < condensation.Length; i++)
                {
                    if (!visited[i])
                    {
                        DFSTopological(i, condensation, visited, order);
                    }
                }

                order.Reverse();
                return order;
            }

            private void DFSTopological(int v, List<int>[] graph, bool[] visited, List<int> order)
            {
                visited[v] = true;
                foreach (int u in graph[v])
                {
                    if (!visited[u])
                    {
                        DFSTopological(u, graph, visited, order);
                    }
                }
                order.Add(v);
            }
        }

        // 1.14: Задача коммивояжера (TSP)
        public class TSP_Solver
        {
            private double[,] distances;
            private int n;

            public TSP_Solver(double[,] distMatrix)
            {
                distances = distMatrix;
                n = distMatrix.GetLength(0);
            }

            // Точное решение методом динамического программирования
            public (List<int> path, double cost) SolveDP()
            {
                int stateSize = 1 << n;
                var dp = new double[stateSize, n];
                var parent = new int[stateSize, n];

                for (int i = 0; i < stateSize; i++)
                    for (int j = 0; j < n; j++)
                        dp[i, j] = double.MaxValue;

                dp[1, 0] = 0;

                for (int mask = 1; mask < stateSize; mask += 2)
                {
                    for (int u = 0; u < n; u++)
                    {
                        if ((mask & (1 << u)) == 0) continue;

                        for (int v = 0; v < n; v++)
                        {
                            if ((mask & (1 << v)) != 0) continue;

                            int newMask = mask | (1 << v);
                            double newCost = dp[mask, u] + distances[u, v];

                            if (newCost < dp[newMask, v])
                            {
                                dp[newMask, v] = newCost;
                                parent[newMask, v] = u;
                            }
                        }
                    }
                }

                double minCost = double.MaxValue;
                int last = -1;
                int finalMask = stateSize - 1;

                for (int v = 1; v < n; v++)
                {
                    double cost = dp[finalMask, v] + distances[v, 0];
                    if (cost < minCost)
                    {
                        minCost = cost;
                        last = v;
                    }
                }

                var path = ReconstructPath(parent, finalMask, last);
                return (path, minCost);
            }

            private List<int> ReconstructPath(int[,] parent, int mask, int last)
            {
                var path = new List<int>();
                int current = last;
                int currentMask = mask;

                while (current != 0)
                {
                    path.Add(current);
                    int prev = parent[currentMask, current];
                    currentMask ^= 1 << current;
                    current = prev;
                }

                path.Add(0);
                path.Reverse();
                path.Add(0);
                return path;
            }

            // Жадный алгоритм
            public (List<int> path, double cost) SolveGreedy()
            {
                var visited = new bool[n];
                var path = new List<int> { 0 };
                visited[0] = true;
                double totalCost = 0;

                int current = 0;
                for (int i = 1; i < n; i++)
                {
                    int next = -1;
                    double minDist = double.MaxValue;

                    for (int j = 0; j < n; j++)
                    {
                        if (!visited[j] && distances[current, j] < minDist)
                        {
                            minDist = distances[current, j];
                            next = j;
                        }
                    }

                    path.Add(next);
                    visited[next] = true;
                    totalCost += minDist;
                    current = next;
                }

                totalCost += distances[current, 0];
                path.Add(0);

                return (path, totalCost);
            }

            // Алгоритм Кристофидеса (1.5-приближение)
            public (List<int> path, double cost) SolveChristofides()
            {
                var mst = FindMST();
                var oddVertices = FindOddDegreeVertices(mst);
                var perfectMatching = FindMinimumPerfectMatching(oddVertices);
                var eulerian = CombineMSTAndMatching(mst, perfectMatching);
                var path = HamiltonianCycleFromEulerian(eulerian);

                double cost = CalculatePathCost(path);
                return (path, cost);
            }

            private List<(int, int)> FindMST()
            {
                var edges = new List<(int, int, double)>();
                for (int i = 0; i < n; i++)
                    for (int j = i + 1; j < n; j++)
                        edges.Add((i, j, distances[i, j]));

                edges.Sort((a, b) => a.Item3.CompareTo(b.Item3));

                var uf = new UnionFind(n);
                var mst = new List<(int, int)>();

                foreach (var edge in edges)
                {
                    if (uf.Union(edge.Item1, edge.Item2))
                    {
                        mst.Add((edge.Item1, edge.Item2));
                    }
                }

                return mst;
            }

            private List<int> FindOddDegreeVertices(List<(int, int)> mst)
            {
                var degree = new int[n];
                foreach (var edge in mst)
                {
                    degree[edge.Item1]++;
                    degree[edge.Item2]++;
                }

                var oddVertices = new List<int>();
                for (int i = 0; i < n; i++)
                {
                    if (degree[i] % 2 == 1)
                        oddVertices.Add(i);
                }

                return oddVertices;
            }

            private List<(int, int)> FindMinimumPerfectMatching(List<int> vertices)
            {
                var matching = new List<(int, int)>();
                var used = new bool[n];

                for (int i = 0; i < vertices.Count; i++)
                {
                    if (used[vertices[i]]) continue;

                    int bestMatch = -1;
                    double bestDist = double.MaxValue;

                    for (int j = i + 1; j < vertices.Count; j++)
                    {
                        if (!used[vertices[j]])
                        {
                            double dist = distances[vertices[i], vertices[j]];
                            if (dist < bestDist)
                            {
                                bestDist = dist;
                                bestMatch = j;
                            }
                        }
                    }

                    if (bestMatch != -1)
                    {
                        matching.Add((vertices[i], vertices[bestMatch]));
                        used[vertices[i]] = true;
                        used[vertices[bestMatch]] = true;
                    }
                }

                return matching;
            }

            private List<int>[] CombineMSTAndMatching(List<(int, int)> mst, List<(int, int)> matching)
            {
                var graph = new List<int>[n];
                for (int i = 0; i < n; i++)
                    graph[i] = new List<int>();

                foreach (var edge in mst)
                {
                    graph[edge.Item1].Add(edge.Item2);
                    graph[edge.Item2].Add(edge.Item1);
                }

                foreach (var edge in matching)
                {
                    graph[edge.Item1].Add(edge.Item2);
                    graph[edge.Item2].Add(edge.Item1);
                }

                return graph;
            }

            private List<int> HamiltonianCycleFromEulerian(List<int>[] eulerianGraph)
            {
                var visited = new bool[n];
                var path = new List<int>();
                DFSEulerian(0, eulerianGraph, visited, path);
                path.Add(0);
                return path;
            }

            private void DFSEulerian(int v, List<int>[] graph, bool[] visited, List<int> path)
            {
                visited[v] = true;
                path.Add(v);

                foreach (int u in graph[v])
                {
                    if (!visited[u])
                    {
                        DFSEulerian(u, graph, visited, path);
                    }
                }
            }

            private double CalculatePathCost(List<int> path)
            {
                double cost = 0;
                for (int i = 0; i < path.Count - 1; i++)
                {
                    cost += distances[path[i], path[i + 1]];
                }
                return cost;
            }

            // Муравьиный алгоритм
            public (List<int> path, double cost) SolveAntColony(int iterations = 1000, int ants = 50,
                double alpha = 1.0, double beta = 2.0, double evaporation = 0.5)
            {
                var pheromone = new double[n, n];
                for (int i = 0; i < n; i++)
                    for (int j = 0; j < n; j++)
                        pheromone[i, j] = 1.0;

                List<int> bestPath = null;
                double bestCost = double.MaxValue;

                for (int iter = 0; iter < iterations; iter++)
                {
                    var antPaths = new List<List<int>>();
                    var antCosts = new List<double>();

                    for (int ant = 0; ant < ants; ant++)
                    {
                        var path = ConstructAntPath(pheromone, alpha, beta);
                        double cost = CalculatePathCost(path);
                        antPaths.Add(path);
                        antCosts.Add(cost);

                        if (cost < bestCost)
                        {
                            bestCost = cost;
                            bestPath = path;
                        }
                    }

                    UpdatePheromones(pheromone, antPaths, antCosts, evaporation);
                }

                return (bestPath, bestCost);
            }

            private List<int> ConstructAntPath(double[,] pheromone, double alpha, double beta)
            {
                var path = new List<int>();
                var visited = new bool[n];
                path.Add(0);
                visited[0] = true;

                int current = 0;
                for (int i = 1; i < n; i++)
                {
                    int next = SelectNextCity(current, visited, pheromone, alpha, beta);
                    path.Add(next);
                    visited[next] = true;
                    current = next;
                }

                path.Add(0);
                return path;
            }

            private int SelectNextCity(int current, bool[] visited, double[,] pheromone, double alpha, double beta)
            {
                var probabilities = new double[n];
                double total = 0;

                for (int i = 0; i < n; i++)
                {
                    if (!visited[i])
                    {
                        probabilities[i] = Math.Pow(pheromone[current, i], alpha) *
                                          Math.Pow(1.0 / distances[current, i], beta);
                        total += probabilities[i];
                    }
                }

                double random = new Random().NextDouble() * total;
                double cumulative = 0;

                for (int i = 0; i < n; i++)
                {
                    if (!visited[i])
                    {
                        cumulative += probabilities[i];
                        if (cumulative >= random)
                            return i;
                    }
                }

                return -1;
            }

            private void UpdatePheromones(double[,] pheromone, List<List<int>> paths, List<double> costs, double evaporation)
            {
                for (int i = 0; i < n; i++)
                    for (int j = 0; j < n; j++)
                        pheromone[i, j] *= (1 - evaporation);

                for (int k = 0; k < paths.Count; k++)
                {
                    double delta = 1.0 / costs[k];
                    var path = paths[k];

                    for (int i = 0; i < path.Count - 1; i++)
                    {
                        pheromone[path[i], path[i + 1]] += delta;
                        pheromone[path[i + 1], path[i]] += delta;
                    }
                }
            }
        }

        // 1.15: Поиск отрицательных циклов
        public class NegativeCycleFinder
        {
            private class Edge
            {
                public int From { get; set; }
                public int To { get; set; }
                public double Weight { get; set; }
            }

            private List<Edge> edges;
            private int vertices;

            public NegativeCycleFinder(int vertices)
            {
                this.vertices = vertices;
                edges = new List<Edge>();
            }

            public void AddEdge(int from, int to, double weight)
            {
                edges.Add(new Edge { From = from, To = to, Weight = weight });
            }

            public (bool hasCycle, List<int> cycle) FindNegativeCycle()
            {
                var distance = new double[vertices];
                var parent = new int[vertices];
                Array.Fill(parent, -1);

                int lastUpdated = -1;

                for (int i = 0; i < vertices; i++)
                {
                    lastUpdated = -1;
                    foreach (var edge in edges)
                    {
                        if (distance[edge.From] + edge.Weight < distance[edge.To])
                        {
                            distance[edge.To] = distance[edge.From] + edge.Weight;
                            parent[edge.To] = edge.From;
                            lastUpdated = edge.To;
                        }
                    }
                }

                if (lastUpdated == -1)
                    return (false, null);

                for (int i = 0; i < vertices; i++)
                {
                    lastUpdated = parent[lastUpdated];
                }

                var cycle = new List<int>();
                int current = lastUpdated;

                do
                {
                    cycle.Add(current);
                    current = parent[current];
                } while (current != lastUpdated && cycle.Count <= vertices);

                cycle.Reverse();
                return (true, cycle);
            }

            public bool[] FindReachableFromSource(int source)
            {
                var reachable = new bool[vertices];
                DFS(source, reachable);
                return reachable;
            }

            private void DFS(int v, bool[] reachable)
            {
                reachable[v] = true;
                foreach (var edge in edges)
                {
                    if (edge.From == v && !reachable[edge.To])
                    {
                        DFS(edge.To, reachable);
                    }
                }
            }

            public List<int> FindUnreachableVertices(int source)
            {
                var reachable = FindReachableFromSource(source);
                var unreachable = new List<int>();

                for (int i = 0; i < vertices; i++)
                {
                    if (!reachable[i])
                        unreachable.Add(i);
                }

                return unreachable;
            }
        }

        // 1.16: MST с ограничениями
        public class ConstrainedMST
        {
            public class Edge : IComparable<Edge>
            {
                public int From { get; set; }
                public int To { get; set; }
                public int Weight { get; set; }

                public int CompareTo(Edge other)
                {
                    return Weight.CompareTo(other.Weight);
                }
            }

            private List<Edge> edges;
            private int vertices;

            public ConstrainedMST(int vertices)
            {
                this.vertices = vertices;
                edges = new List<Edge>();
            }

            public void AddEdge(int from, int to, int weight)
            {
                edges.Add(new Edge { From = from, To = to, Weight = weight });
            }

            public (List<Edge> mst, int totalWeight) FindMSTWithMaxDegree(int maxDegree)
            {
                var sortedEdges = edges.OrderBy(e => e.Weight).ToList();
                var mst = new List<Edge>();
                var uf = new UnionFind(vertices);
                var degree = new int[vertices];

                foreach (var edge in sortedEdges)
                {
                    if (uf.Connected(edge.From, edge.To))
                        continue;

                    if (degree[edge.From] < maxDegree && degree[edge.To] < maxDegree)
                    {
                        uf.Union(edge.From, edge.To);
                        mst.Add(edge);
                        degree[edge.From]++;
                        degree[edge.To]++;

                        if (mst.Count == vertices - 1)
                            break;
                    }
                }

                int totalWeight = mst.Sum(e => e.Weight);
                return (mst, totalWeight);
            }

            public (List<Edge> mst, int totalWeight) FindMSTWithMinDiameter()
            {
                var allEdges = edges.OrderBy(e => e.Weight).ToList();
                var bestMST = new List<Edge>();
                int bestDiameter = int.MaxValue;

                for (int i = 0; i < allEdges.Count; i++)
                {
                    var mst = new List<Edge>();
                    var uf = new UnionFind(vertices);

                    mst.Add(allEdges[i]);
                    uf.Union(allEdges[i].From, allEdges[i].To);

                    foreach (var edge in allEdges)
                    {
                        if (uf.Union(edge.From, edge.To))
                        {
                            mst.Add(edge);
                        }
                    }

                    if (mst.Count == vertices - 1)
                    {
                        int diameter = CalculateDiameter(mst);
                        if (diameter < bestDiameter)
                        {
                            bestDiameter = diameter;
                            bestMST = mst;
                        }
                    }
                }

                int totalWeight = bestMST.Sum(e => e.Weight);
                return (bestMST, totalWeight);
            }

            private int CalculateDiameter(List<Edge> tree)
            {
                var graph = new List<int>[vertices];
                for (int i = 0; i < vertices; i++)
                    graph[i] = new List<int>();

                foreach (var edge in tree)
                {
                    graph[edge.From].Add(edge.To);
                    graph[edge.To].Add(edge.From);
                }

                int diameter = 0;
                for (int i = 0; i < vertices; i++)
                {
                    var dist = BFS(i, graph);
                    diameter = Math.Max(diameter, dist.Max());
                }

                return diameter;
            }

            private int[] BFS(int start, List<int>[] graph)
            {
                var dist = new int[vertices];
                Array.Fill(dist, -1);
                var queue = new Queue<int>();

                dist[start] = 0;
                queue.Enqueue(start);

                while (queue.Count > 0)
                {
                    int u = queue.Dequeue();
                    foreach (int v in graph[u])
                    {
                        if (dist[v] == -1)
                        {
                            dist[v] = dist[u] + 1;
                            queue.Enqueue(v);
                        }
                    }
                }

                return dist;
            }

            public (List<Edge> mst, int totalWeight) FindMSTWithMaxEdgeWeight(int maxEdgeWeight)
            {
                var filteredEdges = edges.Where(e => e.Weight <= maxEdgeWeight).ToList();
                filteredEdges.Sort((a, b) => a.Weight.CompareTo(b.Weight));

                var mst = new List<Edge>();
                var uf = new UnionFind(vertices);
                int totalWeight = 0;

                foreach (var edge in filteredEdges)
                {
                    if (uf.Union(edge.From, edge.To))
                    {
                        mst.Add(edge);
                        totalWeight += edge.Weight;

                        if (mst.Count == vertices - 1)
                            break;
                    }
                }

                return (mst, totalWeight);
            }
        }

        // 1.17: Алгоритм Кнута-Морриса-Пратта
        public class KMP_Matcher
        {
            public List<int> Search(string text, string pattern)
            {
                var result = new List<int>();
                if (string.IsNullOrEmpty(pattern)) return result;

                var lps = ComputeLPS(pattern);
                int i = 0, j = 0;

                while (i < text.Length)
                {
                    if (pattern[j] == text[i])
                    {
                        i++;
                        j++;
                    }

                    if (j == pattern.Length)
                    {
                        result.Add(i - j);
                        j = lps[j - 1];
                    }
                    else if (i < text.Length && pattern[j] != text[i])
                    {
                        if (j != 0)
                            j = lps[j - 1];
                        else
                            i++;
                    }
                }

                return result;
            }

            private int[] ComputeLPS(string pattern)
            {
                var lps = new int[pattern.Length];
                int len = 0;
                int i = 1;

                while (i < pattern.Length)
                {
                    if (pattern[i] == pattern[len])
                    {
                        len++;
                        lps[i] = len;
                        i++;
                    }
                    else
                    {
                        if (len != 0)
                        {
                            len = lps[len - 1];
                        }
                        else
                        {
                            lps[i] = 0;
                            i++;
                        }
                    }
                }

                return lps;
            }

            public List<int> SearchWithWildcard(string text, string pattern, char wildcard = '?')
            {
                var result = new List<int>();
                if (string.IsNullOrEmpty(pattern)) return result;

                for (int i = 0; i <= text.Length - pattern.Length; i++)
                {
                    bool match = true;
                    for (int j = 0; j < pattern.Length; j++)
                    {
                        if (pattern[j] != wildcard && pattern[j] != text[i + j])
                        {
                            match = false;
                            break;
                        }
                    }
                    if (match)
                        result.Add(i);
                }

                return result;
            }

            public List<int> FindPeriodicPatterns(string text, int minPeriod = 2, int maxPeriod = 100)
            {
                var result = new List<int>();
                for (int period = minPeriod; period <= Math.Min(maxPeriod, text.Length / 2); period++)
                {
                    for (int start = 0; start <= text.Length - 2 * period; start++)
                    {
                        bool isPeriodic = true;
                        for (int i = 0; i < period; i++)
                        {
                            if (text[start + i] != text[start + period + i])
                            {
                                isPeriodic = false;
                                break;
                            }
                        }
                        if (isPeriodic)
                            result.Add(start);
                    }
                }
                return result.Distinct().ToList();
            }
        }

        // 1.18: Алгоритм Рабина-Карпа
        public class RabinKarpMatcher
        {
            private const long BASE = 256;
            private const long MOD = 1000000007;

            public List<int> Search(string text, string pattern)
            {
                var result = new List<int>();
                if (string.IsNullOrEmpty(pattern)) return result;

                int n = text.Length;
                int m = pattern.Length;
                if (n < m) return result;

                long patternHash = ComputeHash(pattern);
                long textHash = ComputeHash(text.Substring(0, m));

                long power = 1;
                for (int i = 0; i < m - 1; i++)
                    power = (power * BASE) % MOD;

                for (int i = 0; i <= n - m; i++)
                {
                    if (textHash == patternHash && CheckEqual(text, i, pattern))
                    {
                        result.Add(i);
                    }

                    if (i < n - m)
                    {
                        textHash = (BASE * (textHash - text[i] * power) + text[i + m]) % MOD;
                        if (textHash < 0) textHash += MOD;
                    }
                }

                return result;
            }

            private long ComputeHash(string str)
            {
                long hash = 0;
                foreach (char c in str)
                {
                    hash = (hash * BASE + c) % MOD;
                }
                return hash;
            }

            private bool CheckEqual(string text, int start, string pattern)
            {
                for (int i = 0; i < pattern.Length; i++)
                {
                    if (text[start + i] != pattern[i])
                        return false;
                }
                return true;
            }

            public List<int> SearchMultiplePatterns(string text, string[] patterns)
            {
                var result = new List<int>();
                var patternHashes = new HashSet<long>();

                foreach (var pattern in patterns)
                {
                    patternHashes.Add(ComputeHash(pattern));
                }

                int maxLength = patterns.Max(p => p.Length);
                int minLength = patterns.Min(p => p.Length);

                for (int length = minLength; length <= maxLength; length++)
                {
                    for (int i = 0; i <= text.Length - length; i++)
                    {
                        string substring = text.Substring(i, length);
                        long hash = ComputeHash(substring);

                        if (patternHashes.Contains(hash))
                        {
                            result.Add(i);
                        }
                    }
                }

                return result.Distinct().OrderBy(x => x).ToList();
            }

            public List<(int row, int col)> Search2D(char[,] text, char[,] pattern)
            {
                var result = new List<(int, int)>();
                int n = text.GetLength(0);
                int m = text.GetLength(1);
                int p = pattern.GetLength(0);
                int q = pattern.GetLength(1);

                if (p > n || q > m) return result;

                long patternHash = Compute2DHash(pattern);

                for (int i = 0; i <= n - p; i++)
                {
                    for (int j = 0; j <= m - q; j++)
                    {
                        long subHash = Compute2DHash(text, i, j, p, q);
                        if (subHash == patternHash && Check2DEqual(text, i, j, pattern))
                        {
                            result.Add((i, j));
                        }
                    }
                }

                return result;
            }

            private long Compute2DHash(char[,] matrix, int startRow = 0, int startCol = 0, int rows = -1, int cols = -1)
            {
                if (rows == -1) rows = matrix.GetLength(0);
                if (cols == -1) cols = matrix.GetLength(1);

                long hash = 0;
                for (int i = 0; i < rows; i++)
                {
                    for (int j = 0; j < cols; j++)
                    {
                        hash = (hash * BASE + matrix[startRow + i, startCol + j]) % MOD;
                    }
                }
                return hash;
            }

            private bool Check2DEqual(char[,] text, int startRow, int startCol, char[,] pattern)
            {
                for (int i = 0; i < pattern.GetLength(0); i++)
                {
                    for (int j = 0; j < pattern.GetLength(1); j++)
                    {
                        if (text[startRow + i, startCol + j] != pattern[i, j])
                            return false;
                    }
                }
                return true;
            }
        }

        // 1.19: Внешняя сортировка
        public class ExternalSorter
        {
            private readonly string tempDirectory;
            private readonly int maxMemoryItems;

            public ExternalSorter(string tempDir = null, int maxMemoryItems = 100000)
            {
                tempDirectory = tempDir ?? Path.Combine(Path.GetTempPath(), "external_sort");
                Directory.CreateDirectory(tempDirectory);
                this.maxMemoryItems = maxMemoryItems;
            }

            public void SortLargeFile(string inputFile, string outputFile)
            {
                var chunkFiles = SplitAndSortChunks(inputFile);
                MergeSortedChunks(chunkFiles, outputFile);
                CleanupTempFiles(chunkFiles);
            }

            private List<string> SplitAndSortChunks(string inputFile)
            {
                var chunkFiles = new List<string>();
                int chunkIndex = 0;

                using (var reader = new StreamReader(inputFile))
                {
                    while (!reader.EndOfStream)
                    {
                        var chunk = new List<string>();
                        for (int i = 0; i < maxMemoryItems && !reader.EndOfStream; i++)
                        {
                            chunk.Add(reader.ReadLine());
                        }

                        chunk.Sort();
                        string chunkFile = Path.Combine(tempDirectory, $"chunk_{chunkIndex++}.txt");
                        File.WriteAllLines(chunkFile, chunk);
                        chunkFiles.Add(chunkFile);
                    }
                }

                return chunkFiles;
            }

            private void MergeSortedChunks(List<string> chunkFiles, string outputFile)
            {
                var readers = chunkFiles.Select(f => new StreamReader(f)).ToArray();
                var currentLines = new string[readers.Length];
                var minHeap = new SortedSet<(string line, int index)>();

                for (int i = 0; i < readers.Length; i++)
                {
                    currentLines[i] = readers[i].ReadLine();
                    if (currentLines[i] != null)
                    {
                        minHeap.Add((currentLines[i], i));
                    }
                }

                using (var writer = new StreamWriter(outputFile))
                {
                    while (minHeap.Count > 0)
                    {
                        var min = minHeap.Min;
                        minHeap.Remove(min);
                        writer.WriteLine(min.line);

                        int index = min.index;
                        currentLines[index] = readers[index].ReadLine();
                        if (currentLines[index] != null)
                        {
                            minHeap.Add((currentLines[index], index));
                        }
                    }
                }

                foreach (var reader in readers)
                {
                    reader.Close();
                }
            }

            private void CleanupTempFiles(List<string> files)
            {
                foreach (var file in files)
                {
                    File.Delete(file);
                }
            }

            public void OptimizedSort(string inputFile, string outputFile, bool useSSD = true)
            {
                int bufferSize = useSSD ? 8192 : 4096;
                var chunkFiles = SplitAndSortChunksOptimized(inputFile, bufferSize);
                KWayMerge(chunkFiles, outputFile, bufferSize);
                CleanupTempFiles(chunkFiles);
            }

            private List<string> SplitAndSortChunksOptimized(string inputFile, int bufferSize)
            {
                var chunkFiles = new List<string>();
                int chunkIndex = 0;

                using (var reader = new StreamReader(new FileStream(inputFile, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize)))
                {
                    while (!reader.EndOfStream)
                    {
                        var chunk = new List<string>();
                        for (int i = 0; i < maxMemoryItems && !reader.EndOfStream; i++)
                        {
                            chunk.Add(reader.ReadLine());
                        }

                        chunk.Sort();
                        string chunkFile = Path.Combine(tempDirectory, $"chunk_{chunkIndex++}.txt");
                        using (var writer = new StreamWriter(new FileStream(chunkFile, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize)))
                        {
                            foreach (var line in chunk)
                            {
                                writer.WriteLine(line);
                            }
                        }
                        chunkFiles.Add(chunkFile);
                    }
                }

                return chunkFiles;
            }

            private void KWayMerge(List<string> chunkFiles, string outputFile, int bufferSize)
            {
                const int K = 10;
                var tempFiles = new List<string>(chunkFiles);

                while (tempFiles.Count > 1)
                {
                    var newTempFiles = new List<string>();
                    for (int i = 0; i < tempFiles.Count; i += K)
                    {
                        var batch = tempFiles.Skip(i).Take(K).ToList();
                        if (batch.Count == 1)
                        {
                            newTempFiles.Add(batch[0]);
                        }
                        else
                        {
                            string mergedFile = Path.Combine(tempDirectory, $"merge_{Guid.NewGuid()}.txt");
                            MergeBatch(batch, mergedFile, bufferSize);
                            newTempFiles.Add(mergedFile);
                        }
                    }
                    tempFiles = newTempFiles;
                }

                if (tempFiles.Count == 1)
                {
                    File.Move(tempFiles[0], outputFile, true);
                }
            }

            private void MergeBatch(List<string> files, string outputFile, int bufferSize)
            {
                var readers = files.Select(f => new StreamReader(new FileStream(f, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize))).ToArray();
                var currentLines = new string[readers.Length];
                var minHeap = new SortedSet<(string line, int index)>();

                for (int i = 0; i < readers.Length; i++)
                {
                    currentLines[i] = readers[i].ReadLine();
                    if (currentLines[i] != null)
                    {
                        minHeap.Add((currentLines[i], i));
                    }
                }

                using (var writer = new StreamWriter(new FileStream(outputFile, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize)))
                {
                    while (minHeap.Count > 0)
                    {
                        var min = minHeap.Min;
                        minHeap.Remove(min);
                        writer.WriteLine(min.line);

                        int index = min.index;
                        currentLines[index] = readers[index].ReadLine();
                        if (currentLines[index] != null)
                        {
                            minHeap.Add((currentLines[index], index));
                        }
                    }
                }

                foreach (var reader in readers)
                {
                    reader.Close();
                }
            }
        }

        // 1.20: Медиана в потоке данных
        public class StreamingMedian
        {
            private PriorityQueue<double, double> maxHeap;
            private PriorityQueue<double, double> minHeap;

            public StreamingMedian()
            {
                maxHeap = new PriorityQueue<double, double>(Comparer<double>.Create((x, y) => y.CompareTo(x)));
                minHeap = new PriorityQueue<double, double>();
            }

            public void AddNumber(double num)
            {
                if (maxHeap.Count == 0 || num <= maxHeap.Peek())
                {
                    maxHeap.Enqueue(num, num);
                }
                else
                {
                    minHeap.Enqueue(num, num);
                }

                BalanceHeaps();
            }

            private void BalanceHeaps()
            {
                if (maxHeap.Count > minHeap.Count + 1)
                {
                    var num = maxHeap.Dequeue();
                    minHeap.Enqueue(num, num);
                }
                else if (minHeap.Count > maxHeap.Count)
                {
                    var num = minHeap.Dequeue();
                    maxHeap.Enqueue(num, num);
                }
            }

            public double GetMedian()
            {
                if (maxHeap.Count == 0)
                    throw new InvalidOperationException("No numbers added");

                if (maxHeap.Count == minHeap.Count)
                {
                    return (maxHeap.Peek() + minHeap.Peek()) / 2.0;
                }
                else
                {
                    return maxHeap.Peek();
                }
            }

            public void AddNumbers(IEnumerable<double> numbers)
            {
                foreach (var num in numbers)
                {
                    AddNumber(num);
                }
            }

            public void Clear()
            {
                maxHeap.Clear();
                minHeap.Clear();
            }

            public int Count => maxHeap.Count + minHeap.Count;
        }

        // Вспомогательный класс PriorityQueue для .NET
        public class PriorityQueue<TElement, TPriority>
        {
            private readonly SortedDictionary<TPriority, Queue<TElement>> storage;
            private readonly IComparer<TPriority> comparer;

            public int Count { get; private set; }

            public PriorityQueue() : this(Comparer<TPriority>.Default) { }

            public PriorityQueue(IComparer<TPriority> comparer)
            {
                this.comparer = comparer;
                storage = new SortedDictionary<TPriority, Queue<TElement>>(comparer);
                Count = 0;
            }

            public void Enqueue(TElement item, TPriority priority)
            {
                if (!storage.ContainsKey(priority))
                {
                    storage[priority] = new Queue<TElement>();
                }

                storage[priority].Enqueue(item);
                Count++;
            }

            public TElement Dequeue()
            {
                if (Count == 0)
                    throw new InvalidOperationException("Queue is empty");

                var first = storage.First();
                var item = first.Value.Dequeue();
                if (first.Value.Count == 0)
                {
                    storage.Remove(first.Key);
                }
                Count--;
                return item;
            }

            public TElement Peek()
            {
                if (Count == 0)
                    throw new InvalidOperationException("Queue is empty");

                return storage.First().Value.Peek();
            }

            public void Clear()
            {
                storage.Clear();
                Count = 0;
            }
        }

        class Program
        {
            static void Main(string[] args)
            {
                Console.WriteLine("=== КОМПИЛЯЦИЯ АЛГОРИТМОВ ===");
                Console.WriteLine("1. Задача о рюкзаке");
                Console.WriteLine("2. Дерево отрезков");
                Console.WriteLine("3. Алгоритм Дейкстры");
                Console.WriteLine("4. Суффиксное дерево");
                Console.WriteLine("5. Система непересекающихся множеств (Union-Find)");
                Console.WriteLine("6. B-дерево для больших объемов данных");
                Console.WriteLine("7. Приоритетная очередь с уменьшением приоритета");
                Console.WriteLine("8. Максимальный поток (Форд-Фалкерсон)");
                Console.WriteLine("9. Поиск мостов в графе");
                Console.WriteLine("10. Точки сочленения");
                Console.WriteLine("11. LCA (Наименьший общий предок)");
                Console.WriteLine("12. MST (Крускал)");
                Console.WriteLine("13. Сильно связные компоненты");
                Console.WriteLine("14. Задача коммивояжера (TSP)");
                Console.WriteLine("15. Поиск отрицательных циклов");
                Console.WriteLine("16. MST с ограничениями");
                Console.WriteLine("17. Алгоритм KMP");
                Console.WriteLine("18. Алгоритм Рабина-Карпа");
                Console.WriteLine("19. Внешняя сортировка");
                Console.WriteLine("20. Медиана в потоке данных");
                Console.WriteLine();

                TestKnapsack();
                Console.WriteLine("\n" + new string('=', 50));

                TestSegmentTree();
                Console.WriteLine("\n" + new string('=', 50));

                TestGraphAlgorithms();
                Console.WriteLine("\n" + new string('=', 50));

                TestSuffixTree();
                Console.WriteLine("\n" + new string('=', 50));

                TestUnionFind();
                Console.WriteLine("\n" + new string('=', 50));

                TestBTree();
                Console.WriteLine("\n" + new string('=', 50));

                TestPriorityQueue();
                Console.WriteLine("\n" + new string('=', 50));

                TestAdvancedAlgorithms();
            }

            static void TestKnapsack()
            {
                Console.WriteLine("=== ТЕСТ ЗАДАЧИ О РЮКЗАКЕ ===");

                int[] weights = { 2, 3, 4, 5 };
                int[] values = { 3, 4, 5, 6 };
                int capacity = 5;

                Console.WriteLine("Веса: [" + string.Join(", ", weights) + "]");
                Console.WriteLine("Стоимости: [" + string.Join(", ", values) + "]");
                Console.WriteLine("Вместимость: " + capacity);
                Console.WriteLine();

                var result = KnapsackSolver.Solve01Knapsack(weights, values, capacity);
                KnapsackSolver.PrintStepByStepSolution(result, weights, values, capacity);
            }

            static void TestSegmentTree()
            {
                Console.WriteLine("=== ТЕСТ ДЕРЕВА ОТРЕЗКОВ ===");

                long[] array = { 1, 3, 5, 7, 9, 11 };
                Console.WriteLine($"Исходный массив: [{string.Join(", ", array)}]");

                var sumTree = new SegmentTree(array, SegmentTreeOperation.Sum);
                Console.WriteLine($"Сумма [0-2]: {sumTree.Query(0, 2)}");
                Console.WriteLine($"Сумма [2-5]: {sumTree.Query(2, 5)}");
            }

            static void TestGraphAlgorithms()
            {
                Console.WriteLine("=== ТЕСТ АЛГОРИТМОВ НА ГРАФАХ ===");

                var graph = new Graph(6);
                graph.AddEdge(0, 1, 2);
                graph.AddEdge(0, 2, 4);
                graph.AddEdge(1, 2, 1);
                graph.AddEdge(1, 3, 7);
                graph.AddEdge(2, 4, 3);
                graph.AddEdge(3, 4, 1);
                graph.AddEdge(3, 5, 5);
                graph.AddEdge(4, 5, 2);

                int source = 0, target = 5;
                var result = DijkstraAllPaths.FindAllShortestPaths(graph, source);
                var allPaths = DijkstraAllPaths.GetAllShortestPaths(result, target);

                GraphVisualizer.PrintAllPaths(allPaths, result, target);
            }

            static void TestSuffixTree()
            {
                Console.WriteLine("=== СУФФИКСНОЕ ДЕРЕВО И ПОИСК ПОВТОРЯЮЩИХСЯ ПОДСТРОК ===\n");

                TestBasicFunctionality();
                TestPatternSearch();
                TestLongestRepeatedSubstring();
                TestLongestCommonSubstring();

                SuffixTreePerformanceTester.TestPerformance(5000);
            }

            static void TestUnionFind()
            {
                Console.WriteLine("=== СИСТЕМА НЕПЕРЕСЕКАЮЩИХСЯ МНОЖЕСТВ (UNION-FIND) ===\n");

                TestBasicUnionFindOperations();
                TestUnionStrategies();
                TestDynamicGraph();
                TestUnionFindApplications();

                UnionFindPerformanceTester.TestUnionFindPerformance(100000);
                UnionFindPerformanceTester.TestDynamicGraphPerformance();

                TestLargeScaleUnionFind();
            }

            static void TestBTree()
            {
                Console.WriteLine("=== B-ДЕРЕВО ДЛЯ БОЛЬШИХ ОБЪЕМОВ ДАННЫХ ===\n");

                TestBasicBTreeOperations();
                TestBTreePerformance();
                TestBTreeWithStrings();
            }

            static void TestPriorityQueue()
            {
                Console.WriteLine("=== ПРИОРИТЕТНАЯ ОЧЕРЕДЬ С УМЕНЬШЕНИЕМ ПРИОРИТЕТА ===\n");

                TestBasicPriorityQueueOperations();
                TestPriorityQueuePerformance();
                TestPriorityQueueDijkstraApplication();
                TestPriorityQueueStress();
            }

            static void TestAdvancedAlgorithms()
            {
                Console.WriteLine("=== ПРОДВИНУТЫЕ АЛГОРИТМЫ (1.8-1.20) ===\n");

                TestMaxFlow();
                TestBridges();
                TestArticulationPoints();
                TestLCA();
                TestKruskalMST();
                TestSCC();
                TestTSP();
                TestNegativeCycle();
                TestConstrainedMST();
                TestKMP();
                TestRabinKarp();
                TestExternalSort();
                TestStreamingMedian();
            }

            // Методы тестирования для SuffixTree
            static void TestBasicFunctionality()
            {
                Console.WriteLine("=== ТЕСТ 1: БАЗОВАЯ ФУНКЦИОНАЛЬНОСТЬ ===");

                string text = "banana";

                Console.WriteLine("Используем простое суффиксное дерево:");
                var simpleTree = new SimpleSuffixTree(text);
                simpleTree.PrintTree();

                Console.WriteLine("\nПоиск суффиксов в простом дереве:");
                for (int i = 0; i < text.Length; i++)
                {
                    string suffix = text.Substring(i);
                    var positions = simpleTree.SearchPattern(suffix);
                    if (positions.Count > 0)
                    {
                        Console.WriteLine($"Суффикс '{suffix}' найден");
                    }
                }
            }

            static void TestPatternSearch()
            {
                Console.WriteLine("\n=== ТЕСТ 2: ПОИСК ПАТТЕРНОВ ===");

                string text = "this is a test text for testing pattern search";
                var simpleTree = new SimpleSuffixTree(text);

                string[] patterns = { "test", "pattern", "text", "is", "xyz", "ing" };

                foreach (string pattern in patterns)
                {
                    var positions = simpleTree.SearchPattern(pattern);
                    if (positions.Count > 0)
                    {
                        Console.WriteLine($"Паттерн '{pattern}' найден в позициях: [{string.Join(", ", positions)}]");
                    }
                    else
                    {
                        Console.WriteLine($"Паттерн '{pattern}' не найден");
                    }
                }
            }

            static void TestLongestRepeatedSubstring()
            {
                Console.WriteLine("\n=== ТЕСТ 3: ПОИСК ПОВТОРЯЮЩИХСЯ ПОДСТРОК ===");

                string[] testTexts = {
            "banana",
            "abracadabra",
            "mississippi",
            "abcdeabcde",
            "aaaaaa"
        };

                foreach (string text in testTexts)
                {
                    var repeated = AdvancedSuffixOperations.FindAllRepeatedSubstrings(text, 2);
                    string longest = repeated.Count > 0 ? repeated[0] : "";
                    Console.WriteLine($"Текст: '{text}' -> Самая длинная повтор: '{longest}'");

                    if (repeated.Count > 1)
                    {
                        Console.WriteLine($"   Все повторения: {string.Join(", ", repeated.Take(5))}");
                    }
                }
            }

            static void TestLongestCommonSubstring()
            {
                Console.WriteLine("\n=== ТЕСТ 4: НАИБОЛЬШАЯ ОБЩАЯ ПОДСТРОКА ===");

                var testPairs = new[]
                {
            ("abcdef", "zcdemf"),
            ("banana", "ananas"),
            ("computer", "computation"),
            ("hello world", "world peace"),
            ("testing", "ingest")
        };

                foreach (var (text1, text2) in testPairs)
                {
                    string lcs = AdvancedSuffixOperations.FindLongestCommonSubstring(text1, text2);
                    Console.WriteLine($"'{text1}' и '{text2}' -> Общая подстрока: '{lcs}'");
                }
            }

            static void TestBasicUnionFindOperations()
            {
                Console.WriteLine("=== ТЕСТ 1: БАЗОВЫЕ ОПЕРАЦИИ UNION-FIND ===");

                var uf = new UnionFind(10, UnionStrategy.ByRank);

                Console.WriteLine("Изначально: 10 компонент");
                uf.Union(0, 1);
                uf.Union(2, 3);
                uf.Union(4, 5);
                Console.WriteLine($"После 3 объединений: {uf.Components} компонент");

                uf.Union(1, 2);
                Console.WriteLine($"После объединения 1 и 2: {uf.Components} компонент");

                Console.WriteLine($"0 и 3 связаны: {uf.Connected(0, 3)}");
                Console.WriteLine($"0 и 4 связаны: {uf.Connected(0, 4)}");

                uf.PrintStats();
            }

            static void TestUnionStrategies()
            {
                Console.WriteLine("\n=== ТЕСТ 2: СРАВНЕНИЕ СТРАТЕГИЙ UNION-FIND ===");

                int n = 100;
                var ufRank = new UnionFind(n, UnionStrategy.ByRank);
                var ufSize = new UnionFind(n, UnionStrategy.BySize);

                var random = new Random();

                for (int i = 0; i < n / 2; i++)
                {
                    int a = random.Next(n);
                    int b = random.Next(n);
                    ufRank.Union(a, b);
                    ufSize.Union(a, b);
                }

                Console.WriteLine("By Rank - итоговые компоненты: " + ufRank.Components);
                Console.WriteLine("By Size - итоговые компоненты: " + ufSize.Components);

                bool identical = true;
                for (int i = 0; i < n; i++)
                {
                    for (int j = i + 1; j < n; j++)
                    {
                        if (ufRank.Connected(i, j) != ufSize.Connected(i, j))
                        {
                            identical = false;
                            break;
                        }
                    }
                }

                Console.WriteLine($"Результаты идентичны: {identical}");
            }

            static void TestDynamicGraph()
            {
                Console.WriteLine("\n=== ТЕСТ 3: ДИНАМИЧЕСКИЙ ГРАФ С UNION-FIND ===");

                var graph = new DynamicGraph(10, UnionStrategy.BySize);

                graph.AddEdge(0, 1);
                graph.AddEdge(1, 2);
                graph.AddEdge(3, 4);
                graph.AddEdge(4, 5);
                graph.AddEdge(6, 7);
                graph.AddEdge(7, 8);

                Console.WriteLine("После добавления 6 рёбер:");
                graph.PrintGraphInfo();

                graph.AddEdge(2, 3);
                Console.WriteLine("\nПосле объединения компонент:");
                graph.PrintGraphInfo();

                Console.WriteLine($"0 и 5 связаны: {graph.AreConnected(0, 5)}");
                Console.WriteLine($"0 и 8 связаны: {graph.AreConnected(0, 8)}");
            }

            static void TestUnionFindApplications()
            {
                Console.WriteLine("\n=== ТЕСТ 4: ПРИМЕНЕНИЕ UNION-FIND В АЛГОРИТМАХ ===");

                var edges = new List<(int, int)> { (0, 1), (1, 2), (2, 0), (3, 4) };
                bool hasCycle = UnionFindApplications.HasCycle(edges, 5);
                Console.WriteLine($"Граф содержит цикл: {hasCycle}");

                int components = UnionFindApplications.CountConnectedComponents(edges, 5);
                Console.WriteLine($"Количество компонент связности: {components}");

                var weightedEdges = new List<(int, int, int)>
        {
            (0, 1, 4), (0, 2, 1), (1, 2, 2), (1, 3, 5), (2, 3, 8)
        };
                var mst = UnionFindApplications.KruskalMST(weightedEdges, 4);
                Console.WriteLine("Минимальное остовное дерево (Крускал):");
                foreach (var edge in mst)
                {
                    Console.WriteLine($"  {edge.Item1} - {edge.Item2} (вес: {edge.Item3})");
                }
            }

            static void TestLargeScaleUnionFind()
            {
                Console.WriteLine("\n=== ТЕСТ 5: UNION-FIND НА БОЛЬШИХ ДАННЫХ ===");

                int n = 100000;
                var uf = new UnionFind(n, UnionStrategy.BySize);
                var random = new Random();

                var stopwatch = System.Diagnostics.Stopwatch.StartNew();

                for (int i = 1; i < n; i++)
                {
                    uf.Union(i - 1, i);
                }

                var time = stopwatch.ElapsedMilliseconds;
                Console.WriteLine($"Объединение {n} элементов в цепочку: {time} мс");
                Console.WriteLine($"Финальная компонента: {uf.Components}");
                Console.WriteLine($"Размер компоненты: {uf.GetComponentSize(0)}");

                stopwatch.Restart();
                for (int i = 0; i < 100000; i++)
                {
                    uf.Find(random.Next(n));
                }
                var findTime = stopwatch.ElapsedMilliseconds;
                Console.WriteLine($"100000 операций Find: {findTime} мс");
            }

            static void TestBasicBTreeOperations()
            {
                Console.WriteLine("=== ТЕСТ 1: БАЗОВЫЕ ОПЕРАЦИИ B-ДЕРЕВА ===");

                var btree = new BTree<int, string>(minDegree: 2);

                btree.Insert(10, "Value10");
                btree.Insert(20, "Value20");
                btree.Insert(5, "Value5");
                btree.Insert(6, "Value6");
                btree.Insert(12, "Value12");
                btree.Insert(30, "Value30");
                btree.Insert(7, "Value7");
                btree.Insert(17, "Value17");

                Console.WriteLine("Вставлено 8 элементов");

                try
                {
                    var value1 = btree.Search(10);
                    var value2 = btree.Search(5);
                    Console.WriteLine($"Поиск 10: {value1}, Поиск 5: {value2}");
                }
                catch (KeyNotFoundException e)
                {
                    Console.WriteLine(e.Message);
                }

                Console.WriteLine($"Содержит 15: {btree.Contains(15)}");
                Console.WriteLine($"Содержит 20: {btree.Contains(20)}");

                var range = btree.RangeSearch(6, 20);
                Console.WriteLine($"Диапазонный поиск [6-20]: {range.Count} элементов");

                var min = btree.FindMin();
                var max = btree.FindMax();
                Console.WriteLine($"Минимум: {min}, Максимум: {max}");

                Console.WriteLine("\nСтруктура дерева:");
                btree.PrintTree();

                var stats = btree.GetStats();
                stats.PrintStats();

                Console.WriteLine("\n--- Тест удаления ---");
                btree.Delete(10);
                Console.WriteLine("Удален ключ 10");
                Console.WriteLine($"Содержит 10 после удаления: {btree.Contains(10)}");

                btree.FlushToDisk();
                Console.WriteLine("Дерево сохранено на диск");
            }

            static void TestBTreePerformance()
            {
                Console.WriteLine("\n=== ТЕСТ 2: ПРОИЗВОДИТЕЛЬНОСТЬ B-ДЕРЕВА ===");

                BTreePerformanceTester.TestPerformance(5000);
            }

            static void TestBTreeWithStrings()
            {
                Console.WriteLine("\n=== ТЕСТ 3: B-ДЕРЕВО СО СТРОКАМИ ===");

                var btree = new BTree<string, int>();

                btree.Insert("apple", 1);
                btree.Insert("banana", 2);
                btree.Insert("cherry", 3);
                btree.Insert("date", 4);
                btree.Insert("elderberry", 5);

                try
                {
                    var value = btree.Search("banana");
                    Console.WriteLine($"banana -> {value}");

                    var range = btree.RangeSearch("b", "d");
                    Console.WriteLine($"Диапазон [b-d]: {string.Join(", ", range.Select(kv => kv.Key))}");
                }
                catch (KeyNotFoundException e)
                {
                    Console.WriteLine(e.Message);
                }

                Console.WriteLine("Структура строкового дерева:");
                btree.PrintTree();
            }

            static void TestBasicPriorityQueueOperations()
            {
                Console.WriteLine("=== ТЕСТ 1: БАЗОВЫЕ ОПЕРАЦИИ ПРИОРИТЕТНОЙ ОЧЕРЕДИ ===");
                PriorityQueuePerformanceTester.TestBasicOperations();
            }

            static void TestPriorityQueuePerformance()
            {
                Console.WriteLine("=== ТЕСТ 2: ПРОИЗВОДИТЕЛЬНОСТЬ ПРИОРИТЕТНОЙ ОЧЕРЕДИ ===");
                PriorityQueuePerformanceTester.TestPerformance(50000);
            }

            static void TestPriorityQueueDijkstraApplication()
            {
                Console.WriteLine("=== ТЕСТ 3: ПРИМЕНЕНИЕ В АЛГОРИТМЕ ДЕЙКСТРЫ ===");
                PriorityQueuePerformanceTester.TestDijkstraPerformance();
            }

            static void TestPriorityQueueStress()
            {
                Console.WriteLine("=== ТЕСТ 4: СТРЕСС-ТЕСТ ПРИОРИТЕТНОЙ ОЧЕРЕДИ ===");
                PriorityQueuePerformanceTester.TestStress(50000);
            }

            // Методы тестирования для продвинутых алгоритмов (1.8-1.20)
            static void TestMaxFlow()
            {
                Console.WriteLine("1.8: Тест максимального потока");
                var flowFinder = new MaxFlowFinder(6);
                flowFinder.AddEdge(0, 1, 16);
                flowFinder.AddEdge(0, 2, 13);
                flowFinder.AddEdge(1, 2, 10);
                flowFinder.AddEdge(1, 3, 12);
                flowFinder.AddEdge(2, 1, 4);
                flowFinder.AddEdge(2, 4, 14);
                flowFinder.AddEdge(3, 2, 9);
                flowFinder.AddEdge(3, 5, 20);
                flowFinder.AddEdge(4, 3, 7);
                flowFinder.AddEdge(4, 5, 4);

                int maxFlow = flowFinder.FindMaxFlow(0, 5);
                Console.WriteLine($"Максимальный поток: {maxFlow}");
                flowFinder.PrintFlowNetwork();
                Console.WriteLine();
            }

            static void TestBridges()
            {
                Console.WriteLine("1.9: Тест поиска мостов");
                var bridgeFinder = new BridgeFinder(5);
                bridgeFinder.AddEdge(0, 1);
                bridgeFinder.AddEdge(1, 2);
                bridgeFinder.AddEdge(2, 0);
                bridgeFinder.AddEdge(1, 3);
                bridgeFinder.AddEdge(3, 4);

                var bridges = bridgeFinder.FindBridges();
                Console.WriteLine("Мосты: " + string.Join(", ", bridges));
                Console.WriteLine();
            }

            static void TestArticulationPoints()
            {
                Console.WriteLine("1.10: Тест точек сочленения");
                var apFinder = new ArticulationPointsFinder(5);
                apFinder.AddEdge(0, 1);
                apFinder.AddEdge(1, 2);
                apFinder.AddEdge(2, 0);
                apFinder.AddEdge(1, 3);
                apFinder.AddEdge(3, 4);

                var points = apFinder.FindArticulationPoints();
                Console.WriteLine("Точки сочленения: " + string.Join(", ", points));
                Console.WriteLine();
            }

            static void TestLCA()
            {
                Console.WriteLine("1.11: Тест LCA");
                var lcaFinder = new LCAFinder(7);
                lcaFinder.AddEdge(0, 1);
                lcaFinder.AddEdge(0, 2);
                lcaFinder.AddEdge(1, 3);
                lcaFinder.AddEdge(1, 4);
                lcaFinder.AddEdge(2, 5);
                lcaFinder.AddEdge(2, 6);

                lcaFinder.Preprocess(0);
                int lca = lcaFinder.FindLCA(3, 4);
                Console.WriteLine($"LCA(3, 4) = {lca}");
                Console.WriteLine($"Расстояние между 3 и 4: {lcaFinder.FindDistance(3, 4)}");
                Console.WriteLine();
            }

            static void TestKruskalMST()
            {
                Console.WriteLine("1.12: Тест алгоритма Крускала");
                var kruskal = new KruskalMST(4);
                kruskal.AddEdge(0, 1, 10);
                kruskal.AddEdge(0, 2, 6);
                kruskal.AddEdge(0, 3, 5);
                kruskal.AddEdge(1, 3, 15);
                kruskal.AddEdge(2, 3, 4);

                var (mst, weight) = kruskal.FindMST();
                Console.WriteLine($"Вес MST: {weight}");
                Console.WriteLine("Рёбра MST: " + string.Join(", ", mst.Select(e => $"{e.From}-{e.To}({e.Weight})")));
                Console.WriteLine();
            }

            static void TestSCC()
            {
                Console.WriteLine("1.13: Тест сильно связных компонент");
                var sccFinder = new SCCFinder(5);
                sccFinder.AddEdge(0, 1);
                sccFinder.AddEdge(1, 2);
                sccFinder.AddEdge(2, 0);
                sccFinder.AddEdge(1, 3);
                sccFinder.AddEdge(3, 4);

                var scc = sccFinder.FindSCC();
                Console.WriteLine($"Найдено {scc.Count} компонент:");
                foreach (var component in scc)
                {
                    Console.WriteLine("Компонента: " + string.Join(", ", component));
                }
                Console.WriteLine();
            }

            static void TestTSP()
            {
                Console.WriteLine("1.14: Тест задачи коммивояжера");
                double[,] distances = {
            {0, 10, 15, 20},
            {10, 0, 35, 25},
            {15, 35, 0, 30},
            {20, 25, 30, 0}
        };

                var tspSolver = new TSP_Solver(distances);

                var (dpPath, dpCost) = tspSolver.SolveDP();
                Console.WriteLine($"DP: Стоимость = {dpCost}, Путь = {string.Join(" -> ", dpPath)}");

                var (greedyPath, greedyCost) = tspSolver.SolveGreedy();
                Console.WriteLine($"Greedy: Стоимость = {greedyCost}, Путь = {string.Join(" -> ", greedyPath)}");
                Console.WriteLine();
            }

            static void TestNegativeCycle()
            {
                Console.WriteLine("1.15: Тест отрицательных циклов");
                var cycleFinder = new NegativeCycleFinder(4);
                cycleFinder.AddEdge(0, 1, 1);
                cycleFinder.AddEdge(1, 2, -1);
                cycleFinder.AddEdge(2, 3, -1);
                cycleFinder.AddEdge(3, 1, -1);

                var (hasCycle, cycle) = cycleFinder.FindNegativeCycle();
                Console.WriteLine($"Найден отрицательный цикл: {hasCycle}");
                if (hasCycle)
                    Console.WriteLine("Цикл: " + string.Join(" -> ", cycle));
                Console.WriteLine();
            }

            static void TestConstrainedMST()
            {
                Console.WriteLine("1.16: Тест MST с ограничениями");
                var constrainedMST = new ConstrainedMST(4);
                constrainedMST.AddEdge(0, 1, 10);
                constrainedMST.AddEdge(0, 2, 6);
                constrainedMST.AddEdge(0, 3, 5);
                constrainedMST.AddEdge(1, 3, 15);
                constrainedMST.AddEdge(2, 3, 4);

                var (mst, weight) = constrainedMST.FindMSTWithMaxDegree(2);
                Console.WriteLine($"MST с максимальной степенью 2: Вес = {weight}");
                Console.WriteLine();
            }

            static void TestKMP()
            {
                Console.WriteLine("1.17: Тест алгоритма KMP");
                var kmp = new KMP_Matcher();
                string text = "ABABDABACDABABCABAB";
                string pattern = "ABABCABAB";

                var matches = kmp.Search(text, pattern);
                Console.WriteLine($"Найдено вхождений: {matches.Count}");
                Console.WriteLine("Позиции: " + string.Join(", ", matches));
                Console.WriteLine();
            }

            static void TestRabinKarp()
            {
                Console.WriteLine("1.18: Тест алгоритма Рабина-Карпа");
                var rk = new RabinKarpMatcher();
                string text = "ABABDABACDABABCABAB";
                string pattern = "ABABCABAB";

                var matches = rk.Search(text, pattern);
                Console.WriteLine($"Найдено вхождений: {matches.Count}");
                Console.WriteLine("Позиции: " + string.Join(", ", matches));
                Console.WriteLine();
            }

            static void TestExternalSort()
            {
                Console.WriteLine("1.19: Тест внешней сортировки");
                string testFile = "test_input.txt";
                string outputFile = "test_output.txt";

                File.WriteAllLines(testFile, new[] {
            "zebra", "apple", "banana", "cherry", "date",
            "elderberry", "fig", "grape", "honeydew", "kiwi"
        });

                var sorter = new ExternalSorter(maxMemoryItems: 3);
                sorter.SortLargeFile(testFile, outputFile);

                var sortedLines = File.ReadAllLines(outputFile);
                Console.WriteLine("Отсортированные данные: " + string.Join(", ", sortedLines));

                File.Delete(testFile);
                File.Delete(outputFile);
                Console.WriteLine();
            }

            static void TestStreamingMedian()
            {
                Console.WriteLine("1.20: Тест медианы в потоке");
                var medianFinder = new StreamingMedian();
                double[] numbers = { 1, 5, 2, 10, 3, 8, 4 };

                foreach (var num in numbers)
                {
                    medianFinder.AddNumber(num);
                    Console.WriteLine($"После добавления {num}: Медиана = {medianFinder.GetMedian()}");
                }
                Console.WriteLine();
            }
        }
    }
}
